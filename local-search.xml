<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Android工程师不得不知道的App安全点</title>
    <link href="/2020/03/20/Android%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%B8%8D%E5%BE%97%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84App%E5%AE%89%E5%85%A8%E7%82%B9/"/>
    <url>/2020/03/20/Android%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%B8%8D%E5%BE%97%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84App%E5%AE%89%E5%85%A8%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在公司每当上架APP或SDK的时候，很多的安全点是在提交前都要避免掉的，不然提交安全测试也是会被打回，改好再提交。有安全部门审核给业务部门建立一道安全护城墙。假如没有呢？所以以下这些点值得Android工程师明确。</p><h4 id="1、Activity安全"><a href="#1、Activity安全" class="headerlink" title="1、Activity安全"></a>1、Activity安全</h4><p>我们 APP 内的 AndroidManifest.xml 中声明的 Activity 有一个属性 <code>android:exported=&quot;true/false&quot;</code>，如果设为ture的话，就可以被外部调用，假如此时 Activity 接收 Intent 传输数据，就可能恶意伪造数据攻击，导致我们的App出现异常甚至崩溃。</p><p><strong>注意：</strong>没有intent filter默认值为false，有intent filter默认值为true。</p><p>我们可以利用adb shell命令查看当前Activity是否为<code>android:exported=&quot;true&quot;</code>可导出，<code>adb shell am start -n [packname]/[**.ConnectActivity]</code>。若<code>android:exported=&quot;false&quot;</code>，就会爆出下面的异常（Security exception: Permission Denial）。</p><pre><code class="java">Starting: Intent { cmp= packname/**.ConnectActivity }Security exception: Permission Denial: starting Intent { flg=0x10000000 cmp= packname/**.ConnectActivity } from null (pid=7861, uid=2000) not exported from uid 10643</code></pre><p>在没有非常必要的时候，非常有必要手动设置为android:exported=”false”。若是必须设置为可导出，因为我们此时无法知道调用方的身份，所以一定对数据做<strong>正确校验或try-catch当前逻辑</strong>，避免出现麻烦。</p><h4 id="2、BroadcastReceiver-安全"><a href="#2、BroadcastReceiver-安全" class="headerlink" title="2、BroadcastReceiver 安全"></a>2、BroadcastReceiver 安全</h4><p><code>Broadcast Receiver</code> 跟 Activity 都属于四大组件，它也是有导出风险的，当<code>android:exported=&quot;true&quot;</code>，就可以导致外部的广播，若是恶意攻击，便会导致我们的App出现异常甚至崩溃。</p><p>我们可以利用adb shell命令查看当前 <code>Broadcast Receiver</code> 是否为 <code>android:exported=&quot;true&quot;</code> 可导出，<code>adb shell am broadcast send -n [packname]/[**.ConnectReciever]</code>。</p><p>当然，拒绝外部的广播，设置属性<code>android:exported=&quot;false&quot;</code>。</p><h4 id="3、Content-Provider漏洞"><a href="#3、Content-Provider漏洞" class="headerlink" title="3、Content Provider漏洞"></a>3、Content Provider漏洞</h4><p>Content Provider组件，默认的<code>android:exported=&quot;true&quot;</code>，APP定义可以访问本地文件的ContentProvider并实现了<code>ParcelFileDescriptor openFile(Uri uri, String mode)</code>接口方法，它访问内部存储app_webview目录下的数据。如果没有对目标文件地址进行有效判断，通过 <code>../</code> 实现目录跨越对任意私有数据j进行访问。当然这样也可以访问任意外部存储数据。所以内部调用的组件都要设置 <code>android:exported=&quot;false&quot;</code>，并且 ContentProvider 及时做好调用方的身份确认工作，比如获取当前调用者的 uid 或反查调用者的包名与签名进行验证。</p><h4 id="4、Logcat-信息安全"><a href="#4、Logcat-信息安全" class="headerlink" title="4、Logcat 信息安全"></a>4、Logcat 信息安全</h4><p>我们做java中控制台打印信息<code>System.out.println(&quot;打印日志关键信息&quot;);</code> 在Android中用Log类打印日志信息，并在上线时关闭。但难免有些同志会用一下<code>System.out.println</code> 导致关键信息在 <code>adb shell logcat</code> 可以被查看到，导致关键信息泄露，被坏人利用。删除一切使用<code>System.out.println(&quot;打印日志关键信息&quot;);</code> 的代码。</p><h4 id="5、Webview-组件安全"><a href="#5、Webview-组件安全" class="headerlink" title="5、Webview 组件安全"></a>5、Webview 组件安全</h4><p>WebView组件中的接口函数 <code>addJavascriptInterface</code>存在远程代码执行漏洞，远程攻击者利用此漏洞能实现本地 Java 和 javascript 的交互，可对 Android 移动终端进行网页挂木马来控制受影响设备。 </p><p>访问构造的恶意 html 文件，导致执行 adb 系统命令。针对 4.2 以下版本移除JavascriptInterface。在 Android 3.0 以下也需要删除 searchBoxJavaBridge  JavaScript 接口。searchBoxJavaBridge_ 跟 Google 搜索框相关。</p><p>推荐<a href="https://blog.csdn.net/nextdoor6/article/details/52274909">文章</a></p><p>另外，Webview 接口调用系统功能时，我们还可以仅限于该应用的功能范围之内调用。这样的加入<strong>白名单机制</strong>也可以有效的避免使用第三方程序恶意使用发送短信、拨打电话、删除文件等。</p><h4 id="6、APP-更新资源安全"><a href="#6、APP-更新资源安全" class="headerlink" title="6、APP 更新资源安全"></a>6、APP 更新资源安全</h4><p>当我们App升级<strong>更新apk，热更新</strong>部分资源时，对于下载的文件，必须进行校验，包括而不仅限于是否是服务器下载的文件、安装时校验该文件完整性。一般使用<strong>APK公钥签名对比、CRC校验完整性</strong>等，md5不推荐。我们在利用开源的热更新框架时候，必须要考虑到这样，不然就可能会导致致命性的APP伤害，这样的损失将会巨大。</p><h4 id="7、访问https通信不检查证书有效性安全"><a href="#7、访问https通信不检查证书有效性安全" class="headerlink" title="7、访问https通信不检查证书有效性安全"></a>7、访问https通信不检查证书有效性安全</h4><p>在发起HTTPS请求时，如果开发者这样设置了较验证逻辑，<code>setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER)</code> 即忽略了服务端的证书验证，接受任何证书，假如这个时候有中间代理人出现，就是我们常说的中间人攻击的操作，在建立起链接后传输的信息，就会被中间人查看修改，可想而知，非常危险。中间人可以通过设置DNS服务器使客户端与指定的服务器进行通信。另外，也可以使用用的 Fiddler 工具模拟这样的中间人。</p><p>这样的问题，可以实现证书锁定的方法来解决：</p><h5 id="一种是实现X509TrustManager接口："><a href="#一种是实现X509TrustManager接口：" class="headerlink" title="一种是实现X509TrustManager接口："></a>一种是实现X509TrustManager接口：</h5><pre><code class="java">public class HTTPSTrustManager implements X509TrustManager {    private static TrustManager[] trustManagers;    private static final X509Certificate[] _AcceptedIssuers = new X509Certificate[] {};    @Override    public void checkClientTrusted(java.security.cert.X509Certificate[] x509Certificates, String s) throws java.security.cert.CertificateException {        // To change body of implemented methods use File | Settings | File Templates.    }    @Override    public void checkServerTrusted(java.security.cert.X509Certificate[] x509Certificates, String s) throws java.security.cert.CertificateException {        // To change body of implemented methods use File | Settings | File Templates.    }    @Override    public X509Certificate[] getAcceptedIssuers() {        return _AcceptedIssuers;    }    public static void allowAllSSL() {        HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {            @Override            public boolean verify(String arg0, SSLSession arg1) {                return true;            }        });        SSLContext context = null;        if (trustManagers == null) {            trustManagers = new TrustManager[] { new HTTPSTrustManager() };        }        try {            context = SSLContext.getInstance(&quot;TLS&quot;);            context.init(null, trustManagers, new SecureRandom());        } catch (NoSuchAlgorithmException e) {            e.printStackTrace();        } catch (KeyManagementException e) {            e.printStackTrace();        }        HttpsURLConnection.setDefaultSSLSocketFactory(context.getSocketFactory());    }}</code></pre><p>在所有https开始进行请求之前，执行一次即可：</p><pre><code class="java">HTTPSTrustManager.allowAllSSL();//信任所有证书</code></pre><p>就是正常发起https访问：</p><pre><code>httpPostData(context, url, content);</code></pre><h5 id="一种是使用KeyStore："><a href="#一种是使用KeyStore：" class="headerlink" title="一种是使用KeyStore："></a>一种是使用KeyStore：</h5><p>获取到证书放到assert目录下，例如这里使用的证书的文件名为“root.crt”，通过如下函数来读取，并返回SSLContext：</p><pre><code class="java">public static SSLContext getSSLContext(Context inputContext){      SSLContext context = null;        try {            CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);            InputStream in = inputContext.getAssets().open(&quot;root.crt&quot;);            Certificate ca = cf.generateCertificate(in);            KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());            keystore.load(null, null);            keystore.setCertificateEntry(&quot;ca&quot;, ca);            String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();            TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);            tmf.init(keystore);            // Create an SSLContext that uses our TrustManager            context = SSLContext.getInstance(&quot;TLS&quot;);            context.init(null, tmf.getTrustManagers(), null);        } catch (Exception e){            e.printStackTrace();        }        return context;}</code></pre><p>在使用 HttpsURLConnection 的过程中，也就是httpsPostData()函数中使用指定证书的 SSLContext 即可：</p><pre><code class="java">conn.setSSLSocketFactory(getSSLContext(context).getSocketFactory());</code></pre><p>再正常发起网络请求，httpPostData(context, url, content);</p><h4 id="8、信息传递安全"><a href="#8、信息传递安全" class="headerlink" title="8、信息传递安全"></a>8、信息传递安全</h4><p>我们在进行网络信息传递过程中要对数据进行加密，而不是让他们裸奔。不加密的数据，就像脱光了站在大庭广众之下，暴露无遗。这样的解决方案，由开发者视情况而定。比如使用HTTPS，在HTTPS TLS1.2之后已支持ECC加密方式，或制定私有协议（如RSA+AES方案）。保证信息在网络中传输确保不被泄露用户隐私信息。</p><h4 id="9、设备存储信息安全"><a href="#9、设备存储信息安全" class="headerlink" title="9、设备存储信息安全"></a>9、设备存储信息安全</h4><p>在存储信息时，比如sqlite、 xml 、txt 、dat，当然不仅限这几种。都要实施有效的加密手段，对关键的数据存储更应该注意。当然，比如用户密码、加密KEY都是不允许存在本地的。重要信息如果存的是hash值，这也要引起足够的注意，简单Hash可以利用彩虹库有很大概率能碰撞出来。为了极大降低本碰撞出的几率，使用时用一些组合的方式得到hash值，比如password+IMEI。</p><h4 id="10、SharedPreference安全"><a href="#10、SharedPreference安全" class="headerlink" title="10、SharedPreference安全"></a>10、SharedPreference安全</h4><p>当使用SharedPreference来保存数据时，对于敏感信息的key尽量使用缩写或者其他不易知其意的命名，比如：KEY_USER_NAME 应该改为KEY_U_N，或 直接一串md5值做key</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>道路千万条，安全第一条；</p><p>搬砖不规范，同事两行泪。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter Engine 源码编译</title>
    <link href="/2020/01/23/Flutter%20Engine%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"/>
    <url>/2020/01/23/Flutter%20Engine%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<p>本文处理方式以官方配置为主，会更多的注重一些细节。读者可以直接参考官方文档进行编译。</p><blockquote><p>Setting up the Engine development environment<br><a href="https://github.com/flutter/flutter/wiki/Setting-up-the-Engine-development-environment"><a href="https://github.com/flutter/flutter/wiki/Setting-up-the-Engine-development-environment">https://github.com/flutter/flutter/wiki/Setting-up-the-Engine-development-environment</a></a></p></blockquote><h2 id="编译-Flutter-Engine"><a href="#编译-Flutter-Engine" class="headerlink" title="编译 Flutter Engine"></a>编译 Flutter Engine</h2><p>1、准备工作</p><p>安装 <a href="http://commondatastorage.googleapis.com/chrome-infra-docs/flat/depot_tools/docs/html/depot_tools_tutorial.html#_setting_up">depot_tools</a> ：</p><pre><code class="bash">$ git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git</code></pre><p>配置环境变量：建议在 ~/.bash_profile  文件中添加</p><pre><code class="bash">export PATH=/flutter/depot_tools/:$PATH</code></pre><p>然后执行 </p><pre><code class="bash">$ source ~/.bash_profile </code></pre><p>当然，你也可以配置临时环境变量</p><pre><code class="bash">$ export PATH=$PATH:/Users/***/flutter/depot_tools/</code></pre><p>2、将 engine 项目 fork 到自己的<a href="https://github.com/donald99/engine">github</a></p><p>3、创建项目目录</p><p>你可以创建一个目录，名称推荐为 engine，后面的步骤会自动执行 clone ，你也可以先将工程 clone 到本地。</p><pre><code class="bash">$ mkdir engine// 或者将项目 clone 到本地$ git clone https://github.com/donald99/engine</code></pre><p>4、创建 .gclient 文件</p><p>进入engine 目录，创建 .gclient 文件</p><pre><code class="bash">$ cd engine$ vim .gclient</code></pre><p>写入如下内容：</p><pre><code class="bash">solutions = [  {    &quot;managed&quot;: False,    &quot;name&quot;: &quot;src/flutter&quot;,    &quot;url&quot;: &quot;git@github.com:&lt;your_name_here&gt;/engine.git&quot;,    &quot;custom_deps&quot;: {},    &quot;deps_file&quot;: &quot;DEPS&quot;,    &quot;safesync_url&quot;: &quot;&quot;,  },]</code></pre><p>将 <your_name_here> 换成你的 GitHub 名字，例如我的是：</p><pre><code class="bash">solutions = [  {    &quot;managed&quot;: False,    &quot;name&quot;: &quot;src/flutter&quot;,    &quot;url&quot;: &quot;git@github.com:donald99/engine.git&quot;,    &quot;custom_deps&quot;: {},    &quot;deps_file&quot;: &quot;DEPS&quot;,    &quot;safesync_url&quot;: &quot;&quot;,  },]</code></pre><p>:wq 保存退出。</p><p>5、执行 gclient sync 命令</p><p>这里的执行需要梯子，速度根据你的网络状况，同步下来的文件大小大概有 10G</p><pre><code class="bash">$ cd /flutter/engine$ gclient sync</code></pre><p>需要注意的是，这里需要等待文件自动完成，并且尽量不要打断该命令，显示 100% 后仍有很多操作。</p><p>6、重新 fetch flutter/engine 仓库</p><pre><code class="bash">$ cd src/flutter$ git remote add upstream git@github.com:flutter/engine.git</code></pre><p>7、安装辅助工具</p><p>安装 JDK 1.8 以上</p><p>ant 安装</p><pre><code class="bash">$ brew install ant</code></pre><p>8、编译 android 相关</p><p>确保本地 flutter/engine 仓库是最新的</p><pre><code class="bash">$ git pull upstream master$ cd /flutter/engine$ gclient sync</code></pre><p>执行以下命令编译</p><pre><code class="bash">$ ./flutter/tools/gn --unoptimized$ ./flutter/tools/gn --android --unoptimized$ ninja -C out/android_debug_unopt &amp;&amp; ninja -C out/host_debug_unopt</code></pre><p>整个过程比较漫长，耐心等待。</p><p>9、编译 iOS 相关</p><p>确保本地 flutter/engine 仓库是最新的</p><pre><code class="bash">$ git pull upstream master$ cd /flutter/engine$ gclient sync</code></pre><p>执行以下命令编译</p><pre><code class="bash">$ ./flutter/tools/gn --ios --unoptimized$ ./flutter/tools/gn --unoptimized$ ninja -C out/ios_debug_unopt &amp;&amp; ninja -C out/host_debug_unopt</code></pre><p>这样 flutter engine 的编译工作就基本完成了。生成的一些编译文件目录为 src/out 。</p><pre><code class="bash"></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>flutter engine 就像一个小型的操作系统，若研究透彻，就可以纵横天地，心随我意。</p><p>参考资料：<br></p><p><a href="https://github.com/flutter/flutter/blob/master/CONTRIBUTING.md">https://github.com/flutter/flutter/blob/master/CONTRIBUTING.md</a></p><p>Setting up your engine development environment<br><a href="https://github.com/flutter/flutter/wiki/Setting-up-the-Engine-development-environment">https://github.com/flutter/flutter/wiki/Setting-up-the-Engine-development-environment</a><br>Compiling the engine<br><a href="https://github.com/flutter/flutter/wiki/Compiling-the-engine">https://github.com/flutter/flutter/wiki/Setting-up-the-Engine-development-environment</a><br>Building cquery<br><a href="https://github.com/cquery-project/cquery/wiki/Building-cquery">https://github.com/cquery-project/cquery/wiki/Building-cquery</a><br>Contributing to Flutter<br><a href="https://github.com/flutter/flutter/blob/master/CONTRIBUTING.md">https://github.com/flutter/flutter/blob/master/CONTRIBUTING.md</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter Platform Channel 使用与源码分析</title>
    <link href="/2020/01/10/Flutter%20Platform%20Channel%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2020/01/10/Flutter%20Platform%20Channel%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h3 id="1-PlatformChannel"><a href="#1-PlatformChannel" class="headerlink" title="1. PlatformChannel"></a>1. PlatformChannel</h3><p>为什么要有 PlatformChannel ？</p><p>先来思考以下两个问题：</p><p>1、如果 Flutter 要获取设备的电量信息怎么办？</br><br>2、如果 Flutter 要实时监控网络状态怎么办？</br></p><p>官方 Flutter 给出的特点描述：</p><blockquote><p>Flutter is Google’s UI toolkit for building beautiful, natively compiled applications for mobile, web, and desktop from a single codebase.</p></blockquote><p>1、Flutter 是一个跨平台的 UI 库，专注于构建高效的 UI。</br><br>2、多平台的支持，每个平台的都有自己的平台特性，Flutter 目前支持的平台有：Android、Darwin、Embedder、Fuchsia、Linux、Window。</br></p><p>既然是跨平台的那 Flutter 如何进行平台间通信，此时就需要有一个通道，即今天的主角 PlatformChannel。</p><h3 id="2-架构图"><a href="#2-架构图" class="headerlink" title="2. 架构图"></a>2. 架构图</h3><img src="https://flutter.dev/images/PlatformChannels.png" srcset="/img/loading.gif" width="70%" height="70%" /> <h3 id="3-PlatformChannel-类型"><a href="#3-PlatformChannel-类型" class="headerlink" title="3. PlatformChannel 类型"></a>3. PlatformChannel 类型</h3><ul><li><p>BasicMessageChannel：用于数据传递。</p><p>platform 和 dart 可互相传递数据（asynchronous message passing）</p></li><li><p>MethodChannel：用于传递方法调用。</p><p>platform 和 dart 可互相调用方法（asynchronous method calls）</p></li><li><p>EventChannel：用于数据流通信。</p><p>建立连接之后，platform 发送消息，dart 接收消息（event streams）</p></li></ul><p>三种类型的 channel 都定义在 <code>platform_channel.dart</code> 中，从源码中可以看到三种 channel 都用到了以下三个属性。</p><ul><li><code>name</code>：String 类型，表示 channel 的名字，全局唯一（The logical channel on which communication happens）</li><li><code>codec</code>：MessageCodec<T> 类型，消息的编码解码器（The message codec used by this channel）</li><li><code>binaryMessenger</code>：BinaryMessenger类型，用于发送数据（The messenger used by this channel to send platform messages）</li></ul><h4 id="3-1-channel-name"><a href="#3-1-channel-name" class="headerlink" title="3.1 channel name"></a>3.1 channel name</h4><p>channel 的名字，每个 Flutter 应用可能有多个 channel，但是每个 channel 必须有一个唯一的名字。</p><h4 id="3-2-codec"><a href="#3-2-codec" class="headerlink" title="3.2 codec"></a>3.2 codec</h4><p>codec 用来对数据编码解码，以便两端可以正确读取数据。<br><img src="http://p0.qhimg.com/t01d0c790e129c2c8f9.png" srcset="/img/loading.gif"/> </p><h4 id="3-3-binaryMessenger"><a href="#3-3-binaryMessenger" class="headerlink" title="3.3 binaryMessenger"></a>3.3 binaryMessenger</h4><p>用于发送数据</p><h3 id="4-PlatformChannel-实战"><a href="#4-PlatformChannel-实战" class="headerlink" title="4. PlatformChannel 实战"></a>4. PlatformChannel 实战</h3><h4 id="4-1-MethodChannel"><a href="#4-1-MethodChannel" class="headerlink" title="4.1 MethodChannel"></a>4.1 MethodChannel</h4><ul><li>Dart 调用 Android 方法</li></ul><p>method_channel_page.dart 主要代码</p><pre><code class="dart">第一步static const methodChannel = MethodChannel(&quot;method_channel_sample&quot;);第二步  Future&lt;dynamic&gt; getUserInfo(String method, {String userName}) async {  return await methodChannel.invokeMethod(method, userName);}第三步    MaterialButton(  color: Colors.blue,  textColor: Colors.white,  child: new Text(&#39;获取用户信息&#39;),  onPressed: () {    getUserInfo(&quot;getInfo&quot;, userName: &quot;qihoo&quot;)      ..then((result) {        setState(() {          messageFromNative = result;        });      });  },),</code></pre><p>MainActivity.java 主要代码</p><pre><code class="java">private void addMethodChannel() {    mMethodChannel = new MethodChannel(getFlutterView(), &quot;method_channel_sample&quot;);    mMethodChannel.setMethodCallHandler((methodCall, result) -&gt; {        String method = methodCall.method;        if (&quot;getInfo&quot;.equals(method)) {            String userName = (String) methodCall.arguments;            if (userName.equals(&quot;qihoo&quot;)) {                String user = &quot;name:qihoo, age:1&quot;;                result.success(user);            } else {                result.success(&quot;user not found&quot;);                invokeSayHelloMethod();            }        }    });}</code></pre><p>可以看出首先在 Dart 端定义 MethodChannel 名字为 <code>method_channel_sample</code>。然后定义<code>getUserInfo</code>方法，传入要调用的方法名和参数。最后点击按钮执行方法，获取用户信息。</br><br>在 Android 端定一个 MethodChannel 名字和 Dart 端保持一致。设置 MethodCallHandler。当调用的是<code>getInfo</code>方法时，根据参数返回信息。</p><ul><li>Android 调用 Dart 方法</li></ul><p>MainActivity.java 主要代码</p><pre><code class="java">private void invokeSayHelloMethod() {    mMethodChannel.invokeMethod(&quot;sayHello&quot;, &quot;&quot;, new MethodChannel.Result() {        @Override        public void success(Object o) {            Toast.makeText(MainActivity.this, o.toString(), Toast.LENGTH_LONG).show();        }        @Override        public void error(String s, String s1, Object o) {        }        @Override        public void notImplemented() {        }    });}</code></pre><p>method_channel_page.dart 主要代码</p><pre><code class="dart">Future&lt;dynamic&gt; addHandler(MethodCall call) async {  switch (call.method) {    case &quot;sayHello&quot;:      return &quot;Hello from Flutter&quot;;      break;  }}@overridevoid initState() {  super.initState();  methodChannel.setMethodCallHandler(addHandler);}</code></pre><p>在 Dart 端设置 MethodCallHandler 然后在 Android 端调用即可。</p><h4 id="4-2-BasicMessageChannel"><a href="#4-2-BasicMessageChannel" class="headerlink" title="4.2 BasicMessageChannel"></a>4.2 BasicMessageChannel</h4><ul><li>Dart 向 Android 发送消息</li></ul><p>basic_message_channel_page.dart 主要代码</p><pre><code class="dart">第一步static const basicMessageChannel = BasicMessageChannel(      &quot;basic_message_channel_sample&quot;, StandardMessageCodec());第二步Future&lt;dynamic&gt; sayHelloToNative(String message) async {  String reply = await basicMessageChannel.send(message);  setState(() {    msgReplyFromNative = reply;  });  return reply;}第三步MaterialButton(  color: Colors.blue,  textColor: Colors.white,  child: new Text(&#39;say hello to native&#39;),  onPressed: () {    sayHelloToNative(&quot;hello&quot;);  },),</code></pre><p>MainActivity.java 主要代码</p><pre><code class="java">private void addBasicMessageChannel() {    mBasicMessageChannel = new BasicMessageChannel&lt;&gt;(getFlutterView(), &quot;basic_message_channel_sample&quot;, StandardMessageCodec.INSTANCE);    mBasicMessageChannel.setMessageHandler((object, reply) -&gt; {        reply.reply(&quot;receive &quot; + object.toString() + &quot; from flutter&quot;);        mBasicMessageChannel.send(&quot;native say hello to flutter&quot;);    });}</code></pre><p>可以看出Dart 向 Android 发送消息分为三步。首先在 Dart 端定义 BasicMessageChannel 名字为 <code>basic_message_channel_sample</code>。然后定义发送消息的方法<code>sayHelloToNative</code>。最后点击按钮向 Android 端发送消息。</br><br>在 Android 端定一个 BasicMessageChannel 名字和 Dart 端保持一致。设置 MethodCallHandler。当收到消息时发一个回复。</p><ul><li>Android 向 Dart 发送消息</li></ul><p>MainActivity.java 主要代码</p><pre><code class="java">mBasicMessageChannel.send(&quot;native say hello to flutter&quot;);</code></pre><p>basic_message_channel_page.dart 主要代码</p><pre><code class="dart">Future&lt;dynamic&gt; addHandler(Object result) async {  setState(() {    msgReceiveFromNative = result.toString();  });}void addMessageListener() {  basicMessageChannel.setMessageHandler(addHandler);}@overridevoid initState() {  super.initState();  addMessageListener();}</code></pre><p>从代码可以看出，在 Dart 端设置 MessageHandler 然后在 Android 端直接发送消息即可。</p><h4 id="4-3-EventChannel"><a href="#4-3-EventChannel" class="headerlink" title="4.3 EventChannel"></a>4.3 EventChannel</h4><p>event_channel_page.dart 主要代码</p><pre><code class="dart">第一步static const eventChannel = EventChannel(&quot;event_channel_sample&quot;);void _onEvent(Object event) {  setState(() {    if (_streamSubscription != null) {      eventMessage = event.toString();    }  });}void _onError(Object error) {  setState(() {    if (_streamSubscription != null) {      eventMessage = &quot;error&quot;;    }  });}@overridevoid initState() {  super.initState();  eventMessage = &quot;&quot;;  第二步  _streamSubscription = eventChannel      .receiveBroadcastStream()      .listen(_onEvent, onError: _onError);}</code></pre><p>MainActivity.java 主要代码</p><pre><code class="java">private void addEventChannel() {    mEventChannel = new EventChannel(getFlutterView(), &quot;event_channel_sample&quot;);    mEventChannel.setStreamHandler(new EventChannel.StreamHandler() {        @Override        public void onListen(Object o, EventChannel.EventSink eventSink) {            task = new TimerTask() {                @Override                public void run() {                    runOnUiThread(() -&gt; eventSink.success(&quot;i miss you &quot; + System.currentTimeMillis()));                }            };            timer = new Timer();            timer.schedule(task, 2000, 3000);        }        @Override        public void onCancel(Object o) {            task.cancel();            timer.cancel();            task = null;            timer = null;        }    });}</code></pre><p>Dart 接受 Android stream event。首先在 Dart 端定义 EventChannel 名字为 <code>event_channel_sample</code>。然后设置<code>receiveBroadcastStream</code>监听，当 Android 端有消息发过来会回调<code>_onEvent</code>方法。</br><br>在 Android 端启动一个定时器，每隔3s向 Dart 端发送一次消息。</p><h4 id="4-4-总结"><a href="#4-4-总结" class="headerlink" title="4.4 总结"></a>4.4 总结</h4><p>如下图，在 Dart 与 Platform 通信过程中，通过 channel name 找到对方，然后把消息通过 codec 进行编解码，最后通过 binaryMessenger 进行发送。<br><img src="http://p0.qhimg.com/t01d23cfd7ce4e80077.png" srcset="/img/loading.gif"/> </p><h3 id="5-源码分析-以-MethodChannel-为例"><a href="#5-源码分析-以-MethodChannel-为例" class="headerlink" title="5. 源码分析-以 MethodChannel 为例"></a>5. 源码分析-以 MethodChannel 为例</h3><h5 id="5-1-调用-MethodChannel-的-invokeMethod-方法，会调用到-binaryMessenger-send-方法。即-binaryMessenger-send-传入-channel-name-和编码好的参数。"><a href="#5-1-调用-MethodChannel-的-invokeMethod-方法，会调用到-binaryMessenger-send-方法。即-binaryMessenger-send-传入-channel-name-和编码好的参数。" class="headerlink" title="5.1 调用 MethodChannel 的 invokeMethod 方法，会调用到 binaryMessenger.send 方法。即 binaryMessenger.send 传入 channel name 和编码好的参数。"></a>5.1 调用 MethodChannel 的 invokeMethod 方法，会调用到 binaryMessenger.send 方法。即 binaryMessenger.send 传入 channel name 和编码好的参数。</h5><pre><code class="dart">  @optionalTypeArgs  Future&lt;T&gt; invokeMethod&lt;T&gt;(String method, [ dynamic arguments ]) async {    assert(method != null);    final ByteData result = await binaryMessenger.send(      name,      codec.encodeMethodCall(MethodCall(method, arguments)),    );    if (result == null) {      throw MissingPluginException(&#39;No implementation found for method $method on channel $name&#39;);    }    final T typedResult = codec.decodeEnvelope(result);    return typedResult;  }</code></pre><h5 id="5-2-binary-messenger-dart-的-send-方法会调用当前对象的-sendPlatformMessage-方法，最终会调用-window-sendPlatformMessage-方法。"><a href="#5-2-binary-messenger-dart-的-send-方法会调用当前对象的-sendPlatformMessage-方法，最终会调用-window-sendPlatformMessage-方法。" class="headerlink" title="5.2 binary_messenger.dart 的 send 方法会调用当前对象的 _sendPlatformMessage 方法，最终会调用 window.sendPlatformMessage 方法。"></a>5.2 binary_messenger.dart 的 send 方法会调用当前对象的 _sendPlatformMessage 方法，最终会调用 window.sendPlatformMessage 方法。</h5><pre><code class="dart">  @override  Future&lt;ByteData&gt; send(String channel, ByteData message) {    final MessageHandler handler = _mockHandlers[channel];    if (handler != null)      return handler(message);    return _sendPlatformMessage(channel, message);  }</code></pre><pre><code class="dart">  Future&lt;ByteData&gt; _sendPlatformMessage(String channel, ByteData message) {    final Completer&lt;ByteData&gt; completer = Completer&lt;ByteData&gt;();    // ui.window is accessed directly instead of using ServicesBinding.instance.window    // because this method might be invoked before any binding is initialized.    // This issue was reported in #27541. It is not ideal to statically access    // ui.window because the Window may be dependency injected elsewhere with    // a different instance. However, static access at this location seems to be    // the least bad option.    ui.window.sendPlatformMessage(channel, message, (ByteData reply) {      try {        completer.complete(reply);      } catch (exception, stack) {        FlutterError.reportError(FlutterErrorDetails(          exception: exception,          stack: stack,          library: &#39;services library&#39;,          context: ErrorDescription(&#39;during a platform message response callback&#39;),        ));      }    });    return completer.future;  }</code></pre><h5 id="5-3-在-window-dart-中又调用了-native-方法-sendPlatformMessage。"><a href="#5-3-在-window-dart-中又调用了-native-方法-sendPlatformMessage。" class="headerlink" title="5.3 在 window.dart 中又调用了 native 方法 _sendPlatformMessage。"></a>5.3 在 window.dart 中又调用了 native 方法 _sendPlatformMessage。</h5><pre><code class="dart">  void sendPlatformMessage(String name,                           ByteData data,                           PlatformMessageResponseCallback callback) {    final String error =        _sendPlatformMessage(name, _zonedPlatformMessageResponseCallback(callback), data);    if (error != null)      throw Exception(error);  }</code></pre><pre><code class="dart">  String _sendPlatformMessage(String name,                              PlatformMessageResponseCallback callback,                              ByteData data) native &#39;Window_sendPlatformMessage&#39;;</code></pre><h5 id="5-4-接下来进入-engine-中的-window-cc，可以看到最终调用的是-dart-state-gt-window-gt-client-gt-HandlePlatformMessage。"><a href="#5-4-接下来进入-engine-中的-window-cc，可以看到最终调用的是-dart-state-gt-window-gt-client-gt-HandlePlatformMessage。" class="headerlink" title="5.4 接下来进入 engine 中的 window.cc，可以看到最终调用的是 dart_state-&gt;window()-&gt;client()-&gt;HandlePlatformMessage。"></a>5.4 接下来进入 engine 中的 window.cc，可以看到最终调用的是 dart_state-&gt;window()-&gt;client()-&gt;HandlePlatformMessage。</h5><pre><code class="c++">void Window::RegisterNatives(tonic::DartLibraryNatives* natives) {  natives-&gt;Register({      {&quot;Window_defaultRouteName&quot;, DefaultRouteName, 1, true},      {&quot;Window_scheduleFrame&quot;, ScheduleFrame, 1, true},      {&quot;Window_sendPlatformMessage&quot;, _SendPlatformMessage, 4, true},      {&quot;Window_respondToPlatformMessage&quot;, _RespondToPlatformMessage, 3, true},      {&quot;Window_render&quot;, Render, 2, true},      {&quot;Window_updateSemantics&quot;, UpdateSemantics, 2, true},      {&quot;Window_setIsolateDebugName&quot;, SetIsolateDebugName, 2, true},      {&quot;Window_reportUnhandledException&quot;, ReportUnhandledException, 2, true},      {&quot;Window_setNeedsReportTimings&quot;, SetNeedsReportTimings, 2, true},  });}</code></pre><pre><code class="c++">void _SendPlatformMessage(Dart_NativeArguments args) {  tonic::DartCallStatic(&amp;SendPlatformMessage, args);}</code></pre><pre><code class="c++">Dart_Handle SendPlatformMessage(Dart_Handle window,                                const std::string&amp; name,                                Dart_Handle callback,                                Dart_Handle data_handle) {  UIDartState* dart_state = UIDartState::Current();  if (!dart_state-&gt;window()) {    return tonic::ToDart(        &quot;Platform messages can only be sent from the main isolate&quot;);  }  fml::RefPtr&lt;PlatformMessageResponse&gt; response;  if (!Dart_IsNull(callback)) {    response = fml::MakeRefCounted&lt;PlatformMessageResponseDart&gt;(        tonic::DartPersistentValue(dart_state, callback),        dart_state-&gt;GetTaskRunners().GetUITaskRunner());  }  if (Dart_IsNull(data_handle)) {    dart_state-&gt;window()-&gt;client()-&gt;HandlePlatformMessage(        fml::MakeRefCounted&lt;PlatformMessage&gt;(name, response));  } else {    tonic::DartByteData data(data_handle);    const uint8_t* buffer = static_cast&lt;const uint8_t*&gt;(data.data());    dart_state-&gt;window()-&gt;client()-&gt;HandlePlatformMessage(        fml::MakeRefCounted&lt;PlatformMessage&gt;(            name, std::vector&lt;uint8_t&gt;(buffer, buffer + data.length_in_bytes()),            response));  }  return Dart_Null();}</code></pre><blockquote><p><a href="https://github.com/flutter/engine/blob/master/lib/ui/window/window.cc">window.cc 源码</a></p></blockquote><h5 id="5-5-我们进入-window-h-中找到-client-其实是-WindowClient。"><a href="#5-5-我们进入-window-h-中找到-client-其实是-WindowClient。" class="headerlink" title="5.5 我们进入 window.h 中找到 client 其实是 WindowClient。"></a>5.5 我们进入 window.h 中找到 client 其实是 WindowClient。</h5><pre><code class="c++">  WindowClient* client() const { return client_; }</code></pre><blockquote><p><a href="https://github.com/flutter/engine/blob/master/lib/ui/window/window.h">window.h 源码</a></p></blockquote><h5 id="5-6-在-runtime-controller-h-中可以看到-RuntimeController-是-WindowClient-的实际实现，调用的是-RuntimeController-的-HandlePlatformMessage-方法。"><a href="#5-6-在-runtime-controller-h-中可以看到-RuntimeController-是-WindowClient-的实际实现，调用的是-RuntimeController-的-HandlePlatformMessage-方法。" class="headerlink" title="5.6 在 runtime_controller.h 中可以看到 RuntimeController 是 WindowClient 的实际实现，调用的是 RuntimeController 的 HandlePlatformMessage 方法。"></a>5.6 在 runtime_controller.h 中可以看到 RuntimeController 是 WindowClient 的实际实现，调用的是 RuntimeController 的 HandlePlatformMessage 方法。</h5><pre><code class="c++">class RuntimeController final : public WindowClient {...  // |WindowClient|  void HandlePlatformMessage(fml::RefPtr&lt;PlatformMessage&gt; message) override;...}</code></pre><blockquote><p><a href="https://github.com/flutter/engine/blob/78a8ca0f62b04fa49030ecdd2d91726c0639401f/runtime/runtime_controller.h">runtime_controller.h 源码</a></p></blockquote><h5 id="5-7-在-runtime-controller-cc-中，HandlePlatformMessage-调用了-client-的-HandlePlatformMessage-方法，client-实际是代理对象-RuntimeDelegate。"><a href="#5-7-在-runtime-controller-cc-中，HandlePlatformMessage-调用了-client-的-HandlePlatformMessage-方法，client-实际是代理对象-RuntimeDelegate。" class="headerlink" title="5.7 在 runtime_controller.cc 中，HandlePlatformMessage 调用了 client_ 的 HandlePlatformMessage 方法，client_ 实际是代理对象 RuntimeDelegate。"></a>5.7 在 runtime_controller.cc 中，HandlePlatformMessage 调用了 client_ 的 HandlePlatformMessage 方法，client_ 实际是代理对象 RuntimeDelegate。</h5><pre><code class="c++">void RuntimeController::HandlePlatformMessage(    fml::RefPtr&lt;PlatformMessage&gt; message) {  client_.HandlePlatformMessage(std::move(message));}</code></pre><pre><code class="c++">RuntimeDelegate&amp; p_client</code></pre><blockquote><p><a href="https://github.com/flutter/engine/blob/78a8ca0f62b04fa49030ecdd2d91726c0639401f/runtime/runtime_controller.cc">runtime_controller.cc 源码</a></p></blockquote><h5 id="5-8-engine-h-是-RuntimeDelegate-的具体实现类。"><a href="#5-8-engine-h-是-RuntimeDelegate-的具体实现类。" class="headerlink" title="5.8 engine.h 是 RuntimeDelegate 的具体实现类。"></a>5.8 engine.h 是 RuntimeDelegate 的具体实现类。</h5><pre><code class="c++">class Engine final : public RuntimeDelegate {...  // |RuntimeDelegate|  void HandlePlatformMessage(fml::RefPtr&lt;PlatformMessage&gt; message) override;...  }  </code></pre><blockquote><p><a href="https://github.com/flutter/engine/blob/78a8ca0f62b04fa49030ecdd2d91726c0639401f/shell/common/engine.h">engine.h 源码</a></p></blockquote><h5 id="5-9-engine-cc-中调用了-delegate-的-OnEngineHandlePlatformMessage-方法。"><a href="#5-9-engine-cc-中调用了-delegate-的-OnEngineHandlePlatformMessage-方法。" class="headerlink" title="5.9 engine.cc 中调用了 delegate_ 的 OnEngineHandlePlatformMessage 方法。"></a>5.9 engine.cc 中调用了 delegate_ 的 OnEngineHandlePlatformMessage 方法。</h5><pre><code class="c++">void Engine::HandlePlatformMessage(fml::RefPtr&lt;PlatformMessage&gt; message) {  if (message-&gt;channel() == kAssetChannel) {    HandleAssetPlatformMessage(std::move(message));  } else {    delegate_.OnEngineHandlePlatformMessage(std::move(message));  }}</code></pre><blockquote><p><a href="https://github.com/flutter/engine/blob/78a8ca0f62b04fa49030ecdd2d91726c0639401f/shell/common/engine.cc">engine.cc 源码</a></p></blockquote><h5 id="5-10-shell-h-是-Engine-的代理。"><a href="#5-10-shell-h-是-Engine-的代理。" class="headerlink" title="5.10 shell.h 是 Engine 的代理。"></a>5.10 shell.h 是 Engine 的代理。</h5><pre><code class="c++">  // |Engine::Delegate|  void OnEngineHandlePlatformMessage(      fml::RefPtr&lt;PlatformMessage&gt; message) override;</code></pre><blockquote><p><a href="https://github.com/flutter/engine/blob/ed8e35c4cfe12f836133944c968e00ca52593d43/shell/common/shell.h">shell.h 源码</a></p></blockquote><h5 id="5-11-调用流程又进入了-shell-cc-的-HandleEngineSkiaMessage-方法，把消费放到-TaskRunner-中。"><a href="#5-11-调用流程又进入了-shell-cc-的-HandleEngineSkiaMessage-方法，把消费放到-TaskRunner-中。" class="headerlink" title="5.11 调用流程又进入了 shell.cc 的 HandleEngineSkiaMessage 方法，把消费放到 TaskRunner 中。"></a>5.11 调用流程又进入了 shell.cc 的 HandleEngineSkiaMessage 方法，把消费放到 TaskRunner 中。</h5><pre><code class="c++">// |Engine::Delegate|void Shell::OnEngineHandlePlatformMessage(    fml::RefPtr&lt;PlatformMessage&gt; message) {  FML_DCHECK(is_setup_);  FML_DCHECK(task_runners_.GetUITaskRunner()-&gt;RunsTasksOnCurrentThread());  if (message-&gt;channel() == kSkiaChannel) {    HandleEngineSkiaMessage(std::move(message));    return;  }  task_runners_.GetPlatformTaskRunner()-&gt;PostTask(      [view = platform_view_-&gt;GetWeakPtr(), message = std::move(message)]() {        if (view) {          view-&gt;HandlePlatformMessage(std::move(message));        }      });}</code></pre><blockquote><p><a href="https://github.com/flutter/engine/blob/ed8e35c4cfe12f836133944c968e00ca52593d43/shell/common/shell.cc">shell.cc 源码</a></p></blockquote><h5 id="5-12-当-task-执行是会调用-platform-view-android-h-的-HandlePlatformMessage-方法。"><a href="#5-12-当-task-执行是会调用-platform-view-android-h-的-HandlePlatformMessage-方法。" class="headerlink" title="5.12 当 task 执行是会调用 platform_view_android.h 的 HandlePlatformMessage 方法。"></a>5.12 当 task 执行是会调用 platform_view_android.h 的 HandlePlatformMessage 方法。</h5><pre><code class="c++">class PlatformViewAndroid final : public PlatformView {...  // |PlatformView|  void HandlePlatformMessage(      fml::RefPtr&lt;flutter::PlatformMessage&gt; message) override;...}</code></pre><blockquote><p><a href="https://github.com/flutter/engine/blob/56052c70afcbdff2d39d2af279fcc52666122dbf/shell/platform/android/platform_view_android.h">platform_view_android.h 源码</a> </p></blockquote><h5 id="5-13-在-platform-view-android-cc-的-HandlePlatformMessage-中，开始通过-jni-调用-java-端的方法，java-channel-即要找的-channel。"><a href="#5-13-在-platform-view-android-cc-的-HandlePlatformMessage-中，开始通过-jni-调用-java-端的方法，java-channel-即要找的-channel。" class="headerlink" title="5.13 在 platform_view_android.cc 的 HandlePlatformMessage 中，开始通过 jni 调用 java 端的方法，java_channel 即要找的 channel。"></a>5.13 在 platform_view_android.cc 的 HandlePlatformMessage 中，开始通过 jni 调用 java 端的方法，java_channel 即要找的 channel。</h5><pre><code class="c++">// |PlatformView|void PlatformViewAndroid::HandlePlatformMessage(    fml::RefPtr&lt;flutter::PlatformMessage&gt; message) {  JNIEnv* env = fml::jni::AttachCurrentThread();  fml::jni::ScopedJavaLocalRef&lt;jobject&gt; view = java_object_.get(env);  if (view.is_null())    return;  int response_id = 0;  if (auto response = message-&gt;response()) {    response_id = next_response_id_++;    pending_responses_[response_id] = response;  }  auto java_channel = fml::jni::StringToJavaString(env, message-&gt;channel());  if (message-&gt;hasData()) {    fml::jni::ScopedJavaLocalRef&lt;jbyteArray&gt; message_array(        env, env-&gt;NewByteArray(message-&gt;data().size()));    env-&gt;SetByteArrayRegion(        message_array.obj(), 0, message-&gt;data().size(),        reinterpret_cast&lt;const jbyte*&gt;(message-&gt;data().data()));    message = nullptr;    // This call can re-enter in InvokePlatformMessageXxxResponseCallback.    FlutterViewHandlePlatformMessage(env, view.obj(), java_channel.obj(),                                     message_array.obj(), response_id);  } else {    message = nullptr;    // This call can re-enter in InvokePlatformMessageXxxResponseCallback.    FlutterViewHandlePlatformMessage(env, view.obj(), java_channel.obj(),                                     nullptr, response_id);  }}</code></pre><blockquote><p><a href="https://github.com/flutter/engine/blob/56052c70afcbdff2d39d2af279fcc52666122dbf/shell/platform/android/platform_view_android.cc">platform_view_android.cc 源码</a></p></blockquote><h5 id="5-14-在-platform-view-android-jni-cc-中可以看到-g-handle-platform-message-method-就是-FindClass-“io-flutter-embedding-engine-FlutterJNI”-类的-handlePlatformMessage-方法。至此-engine-代码执行结束。"><a href="#5-14-在-platform-view-android-jni-cc-中可以看到-g-handle-platform-message-method-就是-FindClass-“io-flutter-embedding-engine-FlutterJNI”-类的-handlePlatformMessage-方法。至此-engine-代码执行结束。" class="headerlink" title="5.14 在 platform_view_android_jni.cc 中可以看到 g_handle_platform_message_method 就是 FindClass(“io/flutter/embedding/engine/FlutterJNI”) 类的 handlePlatformMessage 方法。至此 engine 代码执行结束。"></a>5.14 在 platform_view_android_jni.cc 中可以看到 g_handle_platform_message_method 就是 FindClass(“io/flutter/embedding/engine/FlutterJNI”) 类的 handlePlatformMessage 方法。至此 engine 代码执行结束。</h5><pre><code class="c++">static jmethodID g_handle_platform_message_method = nullptr;void FlutterViewHandlePlatformMessage(JNIEnv* env,                                      jobject obj,                                      jstring channel,                                      jobject message,                                      jint responseId) {  env-&gt;CallVoidMethod(obj, g_handle_platform_message_method, channel, message,                      responseId);  FML_CHECK(CheckException(env));}</code></pre><pre><code class="c++">  g_handle_platform_message_method =      env-&gt;GetMethodID(g_flutter_jni_class-&gt;obj(), &quot;handlePlatformMessage&quot;,                       &quot;(Ljava/lang/String;[BI)V&quot;);</code></pre><pre><code class="c++">  g_flutter_jni_class = new fml::jni::ScopedJavaGlobalRef&lt;jclass&gt;(      env, env-&gt;FindClass(&quot;io/flutter/embedding/engine/FlutterJNI&quot;));  if (g_flutter_jni_class-&gt;is_null()) {    FML_LOG(ERROR) &lt;&lt; &quot;Failed to find FlutterJNI Class.&quot;;    return false;  }</code></pre><blockquote><p><a href="https://github.com/flutter/engine/blob/ed8e35c4cfe12f836133944c968e00ca52593d43/shell/platform/android/platform_view_android_jni.cc">platform_view_android_jni.cc 源码</a></p></blockquote><h5 id="5-15-在-FlutterJNI-中调用了-this-platformMessageHandler-handleMessageFromDart-方法。也就是-DartMessenger-的-handleMessageFromDart-方法。"><a href="#5-15-在-FlutterJNI-中调用了-this-platformMessageHandler-handleMessageFromDart-方法。也就是-DartMessenger-的-handleMessageFromDart-方法。" class="headerlink" title="5.15 在 FlutterJNI 中调用了 this.platformMessageHandler.handleMessageFromDart 方法。也就是 DartMessenger 的 handleMessageFromDart 方法。"></a>5.15 在 FlutterJNI 中调用了 this.platformMessageHandler.handleMessageFromDart 方法。也就是 DartMessenger 的 handleMessageFromDart 方法。</h5><pre><code class="java">    private void handlePlatformMessage(@NonNull String channel, byte[] message, int replyId) {        if (this.platformMessageHandler != null) {            this.platformMessageHandler.handleMessageFromDart(channel, message, replyId);        }    }</code></pre><h5 id="5-16-DartMessenger-中-messageHandlers-通过-channel-名找到对应的-handler-进行处理，这个-handler-就是我们在-java-代码里通过-channel-设置的，整个调用流程完成。"><a href="#5-16-DartMessenger-中-messageHandlers-通过-channel-名找到对应的-handler-进行处理，这个-handler-就是我们在-java-代码里通过-channel-设置的，整个调用流程完成。" class="headerlink" title="5.16 DartMessenger 中 messageHandlers 通过 channel 名找到对应的 handler 进行处理，这个 handler 就是我们在 java 代码里通过 channel 设置的，整个调用流程完成。"></a>5.16 DartMessenger 中 messageHandlers 通过 channel 名找到对应的 handler 进行处理，这个 handler 就是我们在 java 代码里通过 channel 设置的，整个调用流程完成。</h5><pre><code class="java">    public void handleMessageFromDart(@NonNull String channel, @Nullable byte[] message, int replyId) {        Log.v(&quot;DartMessenger&quot;, &quot;Received message from Dart over channel &#39;&quot; + channel + &quot;&#39;&quot;);        BinaryMessageHandler handler = (BinaryMessageHandler)this.messageHandlers.get(channel);        if (handler != null) {            try {                Log.v(&quot;DartMessenger&quot;, &quot;Deferring to registered handler to process message.&quot;);                ByteBuffer buffer = message == null ? null : ByteBuffer.wrap(message);                handler.onMessage(buffer, new DartMessenger.Reply(this.flutterJNI, replyId));            } catch (Exception var6) {                Log.e(&quot;DartMessenger&quot;, &quot;Uncaught exception in binary message listener&quot;, var6);                this.flutterJNI.invokePlatformMessageEmptyResponseCallback(replyId);            }        } else {            Log.v(&quot;DartMessenger&quot;, &quot;No registered handler for message. Responding to Dart with empty reply message.&quot;);            this.flutterJNI.invokePlatformMessageEmptyResponseCallback(replyId);        }    }</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://flutter.dev/docs/development/platform-integration/platform-channels">Writing custom platform-specific code</a></br><br><a href="https://github.com/flutter/flutter/tree/master/examples/platform_channel">platform channel 官方示例</a></br><br><a href="https://www.yuque.com/xytech/flutter/fu7h25">深入理解Flutter Platform Channel</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter 图片加载</title>
    <link href="/2019/10/30/Flutter%20%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD/"/>
    <url>/2019/10/30/Flutter%20%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本篇文章你将获得？</p><p>1、Flutter 图片加载方式</p><p>2、Flutter 图片加载源码实现流程</p><p>3、Flutter 图片加载优化点有什么</p><h3 id="Flutter-Image"><a href="#Flutter-Image" class="headerlink" title="Flutter Image"></a>Flutter Image</h3><p>在 Flutter 中 Image 是展示图片的 widget ，用于从 ImageProvider 获取图像。Image 支持的图片格式有 JPEG、WebP、GIF、animated WebP/GIF 、PNG 、BMP、 and WBMP。</p><p>Image 结构如下：<img src="https://p3.ssl.qhimg.com/t01327ab35f7e5254bc.jpg" srcset="/img/loading.gif" alt=""></p><p>可以看到图片上部有多个加载方式。</p><h3 id="Flutter-图片加载方式"><a href="#Flutter-图片加载方式" class="headerlink" title="Flutter 图片加载方式"></a>Flutter 图片加载方式</h3><h5 id="1、Image-asset"><a href="#1、Image-asset" class="headerlink" title="1、Image.asset"></a>1、<a href="https://docs.flutter.io/flutter/widgets/Image/Image.asset.html">Image.asset</a></h5><h5 id="使用-key-从AssetBundle获得的图片；"><a href="#使用-key-从AssetBundle获得的图片；" class="headerlink" title="使用 key 从AssetBundle获得的图片；"></a>使用 key 从AssetBundle获得的图片；</h5><p>两种方式如下：</p><pre><code class="dart">Image(height: 100, width: 100, image: AssetImage(happy.png), )</code></pre><pre><code class="dart">Image.asset( happy.png, width: 100, height: 100,)</code></pre><p>当然这一方式，需要在 pubspec.yaml 文件中配置图片路径。</p><h5 id="2、Image-network"><a href="#2、Image-network" class="headerlink" title="2、Image.network"></a>2、<a href="https://docs.flutter.io/flutter/widgets/Image/Image.network.html">Image.network</a></h5><h5 id="从网络URL中获取图片；"><a href="#从网络URL中获取图片；" class="headerlink" title="从网络URL中获取图片；"></a>从网络URL中获取图片；</h5><pre><code class="dart">Image.network(&#39;https://p0.ssl.qhimg.com/t0183421f63f84fccaf.gif&#39;,fit: BoxFit.fill);</code></pre><h5 id="3、Image-file"><a href="#3、Image-file" class="headerlink" title="3、Image.file"></a>3、<a href="https://docs.flutter.io/flutter/widgets/Image/Image.file.html">Image.file</a></h5><h5 id="从本地文件中获取图片；"><a href="#从本地文件中获取图片；" class="headerlink" title="从本地文件中获取图片；"></a>从本地文件中获取图片；</h5><pre><code class="dart">Image.file(File(&#39;/sdcard/happy.png&#39;)),</code></pre><h5 id="4、Image-memory"><a href="#4、Image-memory" class="headerlink" title="4、Image.memory"></a>4、<a href="https://docs.flutter.io/flutter/widgets/Image/Image.memory.html">Image.memory</a></h5><h5 id="用于从-Uint8List-获取图片；"><a href="#用于从-Uint8List-获取图片；" class="headerlink" title="用于从 Uint8List 获取图片；"></a>用于从 Uint8List 获取图片；</h5><pre><code class="dart">new Image.memory(Uint8List bytes),</code></pre><p><code>bytes</code> 指内存中的图片数据，将其转化为图片对象。</p><p>Flutter 中 Unit8List 与其他语言数据结构类比：</p><table><thead><tr><th>flutter</th><th>java</th><th>swift</th><th>C</th></tr></thead><tbody><tr><td>Uint8List</td><td>byte[]</td><td>FlutterStandardTypedData</td><td>char[]</td></tr></tbody></table><h4 id="其他相关常用的加载图片的方式"><a href="#其他相关常用的加载图片的方式" class="headerlink" title="其他相关常用的加载图片的方式"></a>其他相关常用的加载图片的方式</h4><h5 id="5、CacheNetworkImage"><a href="#5、CacheNetworkImage" class="headerlink" title="5、CacheNetworkImage"></a>5、CacheNetworkImage</h5><h5 id="缓存的网络图片，此类属于-cached-network-image-库；"><a href="#缓存的网络图片，此类属于-cached-network-image-库；" class="headerlink" title="缓存的网络图片，此类属于 cached_network_image 库；"></a>缓存的网络图片，此类属于 cached_network_image 库；</h5><pre><code class="dart">new CachedNetworkImage(    fit:BoxFit.fill,    width:200,    height:100,    imageUrl:&#39;https://p0.ssl.qhimg.com/t0183421f63f84fccaf.gif&#39;,    placeholder:(context, url) =&gt; new ProgressView(),    errorWidget:(context, url, error) =&gt; new Icon(Icons.error),);</code></pre><h5 id="6、FadeInImage-memoryNetwork"><a href="#6、FadeInImage-memoryNetwork" class="headerlink" title="6、FadeInImage.memoryNetwork"></a>6、FadeInImage.memoryNetwork</h5><h5 id="默认占位图和淡入效果"><a href="#默认占位图和淡入效果" class="headerlink" title="默认占位图和淡入效果"></a>默认占位图和淡入效果</h5><pre><code class="dart">import &#39;package:transparent_image/transparent_image.dart&#39;;FadeInImage.memoryNetwork(    placeholder: kTransparentImage, //kTransparentImage 属于 transparent_image 库    image: &#39;https://p0.ssl.qhimg.com/t0183421f63f84fccaf.gif&#39;,);</code></pre><h5 id="7、Icon-Icons-图片参考URL"><a href="#7、Icon-Icons-图片参考URL" class="headerlink" title="7、Icon Icons 图片参考URL"></a>7、Icon <a href="https://material.io/resources/icons/?style=baseline">Icons 图片参考URL</a></h5><pre><code class="dart">new Icon(Icons.android,size: 200,);</code></pre><h3 id="Flutter-加载-images-的分辨率"><a href="#Flutter-加载-images-的分辨率" class="headerlink" title="Flutter 加载 images 的分辨率"></a>Flutter 加载 images 的分辨率</h3><p>Flutter 可以为当前设备加载适合其分辨率的图像。指定不同素设备像比例的图片可以这样分配asset文件夹：</p><ul><li>…icon/happy.png</li><li>…/2.0x/happy.png</li><li>…/3.0x/happy.png</li></ul><p>主资源默认对应于 1.0 倍的分辨率图片；在设备像素比率为 1.8 的设备上会选用 <code>.../2.0x/happy.png</code> ；对于在像素比率 2.7 的设备上 ，会选用 <code>.../3.0x/happy.png</code>。</p><p><code>pubspec.yaml</code>  中 asset 声明中每一项都标识与实际文件对应。但是主资源缺少时，会按分辨率从低到高的顺序寻找加载。这里的加载方案，可以参考 Android 系统中图片加载的逻辑作对比。</p><p>Flutter 打包应用时，资源会按照 key-value 的形式存入 apk 的 assets/flutter_assets/AssetManifest.json 文件中，加载资源时先解析 json 文件，选择最适合的图片进行加载显示，其中 AssetManifest.json 的具体内容简介如：</p><pre><code class="json">{    &quot;assets/happy.png&quot;:[        &quot;assets/2.0x/happy.png&quot;,        &quot;assets/3.0x/happy.png&quot;    ]}</code></pre><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><p>android 上可以通过 AssetManager 获取 asset， 根据 key 查找到 openFd 。</p><p>key 是由 PluginRegistry.Registrar 的 lookupKeyForAsset 与 FlutterView 的 getLookupKeyForAsset 得到；</p><p>PluginRegistry.Registrar 用于开发插件，而 FlutterView 则用于开发平台 app 的 view。</p><h5 id="pubspec-yaml"><a href="#pubspec-yaml" class="headerlink" title="pubspec.yaml"></a>pubspec.yaml</h5><pre><code class="xml">flutter:  assets:    - icons/happy.png</code></pre><h5 id="Java-plugin-code"><a href="#Java-plugin-code" class="headerlink" title="Java plugin code"></a>Java plugin code</h5><pre><code class="java">AssetManager assetManager = registrar.context().getAssets();String key = registrar.lookupKeyForAsset(&quot;icons/happy.png&quot;);AssetFileDescriptor fd = assetManager.openFd(key);</code></pre><h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><p>iOS 开发使用 mainbundle 获取 assets。</p><p>使用 FlutterPluginRegistrar 的 lookupKeyForAsset 和 lookupKeyForAsset:fromPackage: 方法获取文件路径 ；FlutterViewController 的 lookupKeyForAsset 和lookupKeyForAsset:fromPackage: 方法获取文件路径 ；</p><p>然后 FlutterPluginRegistrar 用于开发插件，而 FlutterViewController 则用于开发平台 app 的 view 。</p><h5 id="Objective-C-plugin"><a href="#Objective-C-plugin" class="headerlink" title="Objective-C plugin"></a>Objective-C plugin</h5><pre><code class="objective-c">NSString* key = [registrar lookupKeyForAsset:@&quot;icons/happy.png&quot;];NSString* path = [[NSBundle mainBundle] pathForResource:key ofType:nil];</code></pre><p>当然 pubspec.yaml 配置都是一致的。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>图片加载方式中有四种方式，接下来我们一起看看 framework 层加载图片是如何实现的。我们就以 Image.network 为例，跟进一下相关源码实现。</p><p>Image.network 的方法如下：</p><pre><code class="dart">Image.network(    String src, {    Key key,    double scale = 1.0,    this.frameBuilder,    this.loadingBuilder,    this.semanticLabel,    this.excludeFromSemantics = false,    this.width,    this.height,    this.color,    this.colorBlendMode,    this.fit,    this.alignment = Alignment.center,    this.repeat = ImageRepeat.noRepeat,    this.centerSlice,    this.matchTextDirection = false,    this.gaplessPlayback = false,    this.filterQuality = FilterQuality.low,    Map&lt;String, String&gt; headers,  }) : image = NetworkImage(src, scale: scale, headers: headers),       assert(alignment != null),       assert(repeat != null),       assert(matchTextDirection != null),       super(key: key);</code></pre><p>这方法的作用就是创建一个 用于显示从网络得到的 ImageStream 的 image 小部件，加载网络图片的 image 是由 NetworkImage 创建出来的，其中参数 src, scale, headers 是不能为空的，其他的参数可以不做要求。NetworkImage 又是继承自 ImageProvider，所以 image 就是 ImageProvider 。ImageProvider 是个抽象类，它的实现类包括：NetworkImage、FileImage、ExactAssetImage、AssetImage、MemoryImage、AssetBundleImageProvider。</p><p><img src="https://p3.ssl.qhimg.com/t018f11f7b2fe8e7b04.png" srcset="/img/loading.gif" alt="image-20190926221816329"></p><p>Image 源码部分如下：</p><pre><code class="dart">class Image extends StatefulWidget {/// 用于显示的 image  final ImageProvider image;  ..........  @override  _ImageState createState() =&gt; _ImageState();}</code></pre><p>_ImageState 类</p><pre><code class="dart">class _ImageState extends State&lt;Image&gt; with WidgetsBindingObserver {  ImageStream _imageStream;  ImageInfo _imageInfo;  .......@overridevoid initState() {    super.initState();    WidgetsBinding.instance.addObserver(this);}@overridevoid didChangeDependencies() {    _updateInvertColors();    _resolveImage();//解析图片从这里开始    //设置和移除监听图片变化的回调    if (TickerMode.of(context))      _listenToStream();    else      _stopListeningToStream();    super.didChangeDependencies();}void _resolveImage() {    //根据 ImageConfiguration 调用 ImageProvider 的 resolve 函数获得 ImageStream 对象    final ImageStream newStream = widget.image.resolve(createLocalImageConfiguration(        context,        size: widget.width != null &amp;&amp; widget.height != null ? Size(widget.width, widget.height) : null,      ));    _updateSourceStream(newStream);}  ......}</code></pre><p>它的生命周期方法方法包括<code>initState()</code>、<code>didChangeDependencies()</code>、<code>build()</code>、<code>deactivate()</code>、<code>dispose()</code>、<code>didUpdateWidget()</code> 等等。当它插入到渲染树时，先调用<code>initState()</code>函数，再调用 <code>didChangeDependencies()</code>。代码中可以看到调用了方法 _resolveImage()，这个方法中创建了 ImageStream 的新对象 newStream 。widget.image 就是 ImageProvider，调用resolve方法，代码如下：</p><pre><code class="dart">ImageStream resolve(ImageConfiguration configuration) {  final ImageStream stream = ImageStream();  T obtainedKey;  bool didError = false;  Future&lt;void&gt; handleError(dynamic exception, StackTrace stack) async {    if (didError) {      return;    }    didError = true;    await null; // 等待事件轮询，以防侦听器被添加到图像流中。    final _ErrorImageCompleter imageCompleter = _ErrorImageCompleter();    stream.setCompleter(imageCompleter);    ......  }  ......      Future&lt;T&gt; key;      try {        key = obtainKey(configuration);      } catch (error, stackTrace) {        return;      }      key.then&lt;void&gt;((T key) {        obtainedKey = key;        final ImageStreamCompleter completer =         PaintingBinding.instance.imageCache.putIfAbsent(key, () =&gt; load(key), onError: handleError);        if (completer != null) {          stream.setCompleter(completer);        }      }).catchError(handleError);return stream;</code></pre><p>ImageStreamCompleter 用于管理 dart:ui 加载的类的基类。ImageStreams 的对象很少直接构造，而是由 ImageStreamCompleter 自动配置它。ImageStream 中的图片管理者 ImageStreamCompleter 通过方法创建，imageCache 是 Flutter 框架中实现的用于图片缓存的单例，它这 Dart 虚拟机加载时就已经创建。imageCache 最多可缓存 1000 张图像和 100MB 内存空间。可以使用 [maximumSize] 和 [maximumSizeBytes]调整最大大小。</p><pre><code class="dart">PaintingBinding.instance.imageCache.putIfAbsent(key, () =&gt; load(key), onError: handleError);</code></pre><p>根据源码可以看到两个关键方法 ：putIfAbsent 和 load。</p><h5 id="putIfAbsent"><a href="#putIfAbsent" class="headerlink" title="putIfAbsent"></a>putIfAbsent</h5><pre><code class="dart">ImageStreamCompleter putIfAbsent(Object key, ImageStreamCompleter loader(), {ImageErrorListener onError }) {    ImageStreamCompleter result = _pendingImages[key]?.completer;    // 因为图像还没有加载，不需要做任何事情。    if (result != null)      return result;    // 从缓存列表中根据Key删除对应的 imageprovider，便于将它移动到下面最近使用位置。    final _CachedImage image = _cache.remove(key);    if (image != null) {      _cache[key] = image;      return image.completer;    }    try {      result = loader();    } catch (error, stackTrace) {      ......    }    void listener(ImageInfo info, bool syncCall) {      // 无法加载的图像不会占用缓存大小。      final int imageSize = info?.image == null ? 0 : info.image.height * info.image.width * 4;      final _CachedImage image = _CachedImage(result, imageSize);      // 如果图像大于最大缓存大小，且缓存大小不为零，则将缓存大小增加到图像大小加上 1000。      // 思考点：一直这么加什么时候引起崩溃？      if (maximumSizeBytes &gt; 0 &amp;&amp; imageSize &gt; maximumSizeBytes) {        _maximumSizeBytes = imageSize + 1000;      }      _currentSizeBytes += imageSize;      final _PendingImage pendingImage = _pendingImages.remove(key);      if (pendingImage != null) {        pendingImage.removeListener();      }      _cache[key] = image;      _checkCacheSize();    }    if (maximumSize &gt; 0 &amp;&amp; maximumSizeBytes &gt; 0) {      final ImageStreamListener streamListener = ImageStreamListener(listener);      _pendingImages[key] = _PendingImage(result, streamListener);      // 移除 [_PendingImage.removeListener] 上的监听      result.addListener(streamListener);    }    return result;  }</code></pre><h5 id="load"><a href="#load" class="headerlink" title="load"></a>load</h5><pre><code class="dart">/// 拉取网络图片的 image_provider.NetworkImage 具体实现.class NetworkImage extends image_provider.ImageProvider&lt;image_provider.NetworkImage&gt; implements image_provider.NetworkImage { ......................  @override  ImageStreamCompleter load(image_provider.NetworkImage key) {    final StreamController&lt;ImageChunkEvent&gt; chunkEvents = StreamController&lt;ImageChunkEvent&gt;();    return MultiFrameImageStreamCompleter(      codec: _loadAsync(key, chunkEvents),      chunkEvents: chunkEvents.stream,      scale: key.scale,      informationCollector: () {        return &lt;DiagnosticsNode&gt;[          DiagnosticsProperty&lt;image_provider.ImageProvider&gt;(&#39;Image provider&#39;, this),          DiagnosticsProperty&lt;image_provider.NetworkImage&gt;(&#39;Image key&#39;, key),        ];      },    );  }</code></pre><h5 id="loadAsync"><a href="#loadAsync" class="headerlink" title="loadAsync"></a>loadAsync</h5><pre><code class="dart">Future&lt;ui.Codec&gt; _loadAsync(    NetworkImage key,    StreamController&lt;ImageChunkEvent&gt; chunkEvents,  ) async {    try {      final Uri resolved = Uri.base.resolve(key.url);      final HttpClientRequest request = await _httpClient.getUrl(resolved);      headers?.forEach((String name, String value) {        request.headers.add(name, value);      });      final HttpClientResponse response = await request.close();      if (response.statusCode != HttpStatus.ok)        throw image_provider.NetworkImageLoadException(statusCode: response.statusCode, uri: resolved);        //将网络返回的 response 信息，转换成内存中的 Uint8List bytes。这里面有解压 gzip 的逻辑。      final Uint8List bytes = await consolidateHttpClientResponseBytes(        response,        onBytesReceived: (int cumulative, int total) {          chunkEvents.add(ImageChunkEvent(            cumulativeBytesLoaded: cumulative,            expectedTotalBytes: total,          ));        },      );      if (bytes.lengthInBytes == 0)        throw Exception(&#39;NetworkImage is an empty file: $resolved&#39;);      return PaintingBinding.instance.instantiateImageCodec(bytes);    } finally {      chunkEvents.close();    }  }</code></pre><p>将网络返回的response信息，转换成内存中的 Uint8List bytes，最终返回一个实例化图像编解码器对象Codec，此处 Codec 可以移步到 painting.dart 文件的 _instantiateImageCodec 看出来它是调用了native方法去处理了。</p><h5 id="MultiFrameImageStreamCompleter"><a href="#MultiFrameImageStreamCompleter" class="headerlink" title="MultiFrameImageStreamCompleter"></a>MultiFrameImageStreamCompleter</h5><p>这个对象就是 ImageStreamCompleter 的具体实现，见名知意，多帧图片流管理，作用管理图像帧的解码和调度。</p><p>这个类处理两种类型的帧:</p><ul><li><p>图像帧 ：动画图像的图像帧。</p></li><li><p>app 帧 ：Flutter 引擎绘制到屏幕的帧，显示到应用程序 GUI。</p></li></ul><p>这就不贴所有代码了，在 image_stream.dart 文件中 可见 class MultiFrameImageStreamCompleter。</p><pre><code class="dart">MultiFrameImageStreamCompleter({    @required Future&lt;ui.Codec&gt; codec,    @required double scale,    Stream&lt;ImageChunkEvent&gt; chunkEvents,    InformationCollector informationCollector,  }) : assert(codec != null),       _informationCollector = informationCollector,       _scale = scale {    codec.then&lt;void&gt;(_handleCodecReady, onError: (dynamic error, StackTrace stack) {     ..........    });</code></pre><h5 id="handleCodecReady"><a href="#handleCodecReady" class="headerlink" title="_handleCodecReady"></a>_handleCodecReady</h5><p>这里 codec 异步回调次方法</p><pre><code class="dart">void _handleCodecReady(ui.Codec codec) {    _codec = codec;    if (hasListeners) {      _decodeNextFrameAndSchedule();    }  }</code></pre><h5 id="decodeNextFrameAndSchedule"><a href="#decodeNextFrameAndSchedule" class="headerlink" title="_decodeNextFrameAndSchedule"></a>_decodeNextFrameAndSchedule</h5><p>codec 解码获取到图片的帧数，判断图片是只有一帧的话，就是png、jpg这样静态图片。</p><pre><code class="dart">Future&lt;void&gt; _decodeNextFrameAndSchedule() async {    try {      _nextFrame = await _codec.getNextFrame();    } catch (exception, stack) {      ........      return;    }    if (_codec.frameCount == 1) { // 此处判断图片是只有一帧的逻辑.      _emitFrame(ImageInfo(image: _nextFrame.image, scale: _scale));      return;    }    _scheduleAppFrame();  }  void _scheduleAppFrame() {    if (_frameCallbackScheduled) {      return;    }    _frameCallbackScheduled = true;    SchedulerBinding.instance.scheduleFrameCallback(_handleAppFrame);  }</code></pre><pre><code class="dart">_emitFrame(ImageInfo(image: _nextFrame.image, scale: _scale));void _emitFrame(ImageInfo imageInfo) {    setImage(imageInfo);    _framesEmitted += 1;  }  @protected  void setImage(ImageInfo image) {    _currentImage = image;    if (_listeners.isEmpty)      return;    // 复制一份以允许并发修改。final List&lt;ImageStreamListener&gt; localListeners = List&lt;ImageStreamListener&gt;.from(_listeners);    for (ImageStreamListener listener in localListeners) {      try {        listener.onImage(image, false);      } catch (exception, stack) {        ..........      }    }  }</code></pre><p>setImage 核心逻辑就是通知所有注册上的监听，表示图片发生了变化可以更新啦。此时我们回到 开始提到的_ImageState 类中 didChangeDependencies 方法调用的 _listenToStream 方法，最终调用方法 _handleImageFrame ，改变 图片信息 _imageInfo 和 图片帧数变化 _frameNumber ，最终执行 setState(() {}) 来刷新了 UI。</p><pre><code class="dart">void _listenToStream() {    if (_isListeningToStream)      return;    _imageStream.addListener(_getListener());    _isListeningToStream = true;  }ImageStreamListener _getListener([ImageLoadingBuilder loadingBuilder]) {    loadingBuilder ??= widget.loadingBuilder;    return ImageStreamListener(      _handleImageFrame,      onChunk: loadingBuilder == null ? null : _handleImageChunk,    );  }  void _handleImageFrame(ImageInfo imageInfo, bool synchronousCall) {    setState(() {      _imageInfo = imageInfo;      _loadingProgress = null;      _frameNumber = _frameNumber == null ? 0 : _frameNumber + 1;      _wasSynchronouslyLoaded |= synchronousCall;    });  }</code></pre><p>这样就结束了一个网络图片的加载过程。</p><p>此处应该有流程图就更加简洁明了的表达啦。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>图片加载显示的方式 framework 提供了多种方式，我们就图片网络加载进行了分析。从源码角度对网络图片加载过程有了大致的了解。发现的可以优化点，这里先提出来优化的点：</p><p>1、看到网络图片只是在 ImageCache 管理类中进行了内存缓存，当应用进程重新启动后还是要重新下载图片，此处是可以优化的，比如保存到本地磁盘外存。</p><p>2、拿到图片加载到内存里面的时候，是否有对图片进行压缩处理，这种处理最好既适应当前平台又不过分地改变图片的清晰度。</p><p>期待下一篇的迭代优化点。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>值得庆贺的事情为Flutter社区做贡献</title>
    <link href="/2019/10/28/%E5%80%BC%E5%BE%97%E5%BA%86%E8%B4%BA%E7%9A%84%E4%BA%8B%E6%83%85%E4%B8%BAFlutter%E7%A4%BE%E5%8C%BA%E5%81%9A%E8%B4%A1%E7%8C%AE/"/>
    <url>/2019/10/28/%E5%80%BC%E5%BE%97%E5%BA%86%E8%B4%BA%E7%9A%84%E4%BA%8B%E6%83%85%E4%B8%BAFlutter%E7%A4%BE%E5%8C%BA%E5%81%9A%E8%B4%A1%E7%8C%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="值得纪念的事情"><a href="#值得纪念的事情" class="headerlink" title="值得纪念的事情"></a>值得纪念的事情</h1><p>在6月份的时候，集团内部成立了Flutter兴趣小组，我的领导月影和肆爷大力支持，由我跟小岩一起负责起来。</p><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>主要有两个：1、推进Flutter技术学习并落地到具体业务；2、提高360在Flutter技术方向上的影响力。<br>经过这段时间的，今天收到一个来自 Google 的路哥的信息，将《奇舞团》的称号放到了Flutter中文社区上，很是欣喜。又增加了一点影响力，UP++</p><h1 id="Flutter中文社区网站"><a href="#Flutter中文社区网站" class="headerlink" title="Flutter中文社区网站"></a>Flutter中文社区网站</h1><p>在<a href="https://flutter.cn/about/docs-cn">Flutter中文社区网站</a>查看，这也是对我们付出的一种认可方式，满满的都是感谢。</p><p><img src="https://p.ssl.qhimg.com/t01ed9c62e7b9ba6523.webp" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter 揭密命令行 flutter run</title>
    <link href="/2019/09/02/Flutter%20%E6%8F%AD%E5%AF%86%E5%91%BD%E4%BB%A4%E8%A1%8Cflutter%20run/"/>
    <url>/2019/09/02/Flutter%20%E6%8F%AD%E5%AF%86%E5%91%BD%E4%BB%A4%E8%A1%8Cflutter%20run/</url>
    
    <content type="html"><![CDATA[<p>你将得到什么？</p><p>1、flutter run 命令</p><p>2、针对Android平台run流程做了什么事情？</p><p>赵本山：走两步，沒事走两步。在开发过程中，作为一名称职的开发者，写完代码总是要 run 一下的。知道了通过运行 <code>flutter run</code> 来启动应用，那期间都做了什么事情，这个知道吗？今天我们一起跟一跟这一块的代码~</p><h2 id="flutter-run-命令"><a href="#flutter-run-命令" class="headerlink" title="flutter run 命令"></a>flutter run 命令</h2><p>在 Terminal 执行 flutter run 命令，根据环境变量我们可以知道，flutter 命令，指 ./flutter/bin/flutter 这个shell程序或flutter.bat，这里有跨平台考虑。</p><pre><code class="shell">......FLUTTER_TOOLS_DIR=&quot;$FLUTTER_ROOT/packages/flutter_tools&quot;......SNAPSHOT_PATH=&quot;$FLUTTER_ROOT/bin/cache/flutter_tools.snapshot&quot;......DART_SDK_PATH=&quot;$FLUTTER_ROOT/bin/cache/dart-sdk&quot;DART=&quot;$DART_SDK_PATH/bin/dart&quot;......脚本最后执行了Dart命令&quot;$DART&quot; --packages=&quot;$FLUTTER_TOOLS_DIR/.packages&quot; $FLUTTER_TOOL_ARGS &quot;$SNAPSHOT_PATH&quot; &quot;$@&quot;</code></pre><p>这里我们可以发现，flutter run 命令，执行的就是 dart flutter_tools.snapshot run 。移步到 flutter/packages/flutter_tools/ 项目目录下 flutter_tools.dart</p><h2 id="flutter-tools"><a href="#flutter-tools" class="headerlink" title="flutter_tools"></a>flutter_tools</h2><p>先看一下这个文件的入口函数main代码，如下：</p><pre><code class="dart">import &#39;package:flutter_tools/executable.dart&#39; as executable;void main(List&lt;String&gt; args) {  executable.main(args);}</code></pre><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p>package:flutter_tools/executable.dart</p><pre><code class="dart">/// 命令的进入点/// flutter命令行工具中调用这个函数.Future&lt;void&gt; main(List&lt;String&gt; args) async {  final bool verbose = args.contains(&#39;-v&#39;) || args.contains(&#39;--verbose&#39;);  final bool doctor = (args.isNotEmpty &amp;&amp; args.first == &#39;doctor&#39;) ||      (args.length == 2 &amp;&amp; verbose &amp;&amp; args.last == &#39;doctor&#39;);  final bool help = args.contains(&#39;-h&#39;) || args.contains(&#39;--help&#39;) ||      (args.isNotEmpty &amp;&amp; args.first == &#39;help&#39;) || (args.length == 1 &amp;&amp; verbose);  final bool muteCommandLogging = help || doctor;  final bool verboseHelp = help &amp;&amp; verbose;  await runner.run(args, &lt;FlutterCommand&gt;[    AnalyzeCommand(verboseHelp: verboseHelp),    AssembleCommand(),    AttachCommand(verboseHelp: verboseHelp),    BuildCommand(verboseHelp: verboseHelp),    ChannelCommand(verboseHelp: verboseHelp),    CleanCommand(),    ConfigCommand(verboseHelp: verboseHelp),    CreateCommand(),    DaemonCommand(hidden: !verboseHelp),    DevicesCommand(),    DoctorCommand(verbose: verbose),    DriveCommand(),    EmulatorsCommand(),    FormatCommand(),    GenerateCommand(),    IdeConfigCommand(hidden: !verboseHelp),    InjectPluginsCommand(hidden: !verboseHelp),    InstallCommand(),    LogsCommand(),    MakeHostAppEditableCommand(),    PackagesCommand(),    PrecacheCommand(),    RunCommand(verboseHelp: verboseHelp),    ScreenshotCommand(),    ShellCompletionCommand(),    TestCommand(verboseHelp: verboseHelp),    TrainingCommand(),    UnpackCommand(),    UpdatePackagesCommand(hidden: !verboseHelp),    UpgradeCommand(),    VersionCommand(),  ], verbose: verbose,     muteCommandLogging: muteCommandLogging,     verboseHelp: verboseHelp,     overrides: &lt;Type, Generator&gt;{       CodeGenerator: () =&gt; const BuildRunner(),       WebCompilationProxy: () =&gt; BuildRunnerWebCompilationProxy(),       WebRunnerFactory: () =&gt; DwdsWebRunnerFactory(), // 因为它依赖于dwd,所以内部不支持web运行。     });}</code></pre><p>代码里面，可以看到有各种各样的命令，见名知意，在传进来的参数选择执行不同的命令。这里我们重点关注 run 有关RunCommand。</p><p>package:flutter_tools/runner.dart</p><pre><code class="dart">///  根据指定的[commands]列表，运行Flutter工具。Future&lt;int&gt; run(  List&lt;String&gt; args,  List&lt;FlutterCommand&gt; commands, {  Map&lt;Type, Generator&gt; overrides,}) {    ......省略部分代码......  final FlutterCommandRunner runner = FlutterCommandRunner(verboseHelp: verboseHelp);  commands.forEach(runner.addCommand);  return runInContext&lt;int&gt;(() async {    ...省略部分代码...    Object firstError;    StackTrace firstStackTrace;    return await runZoned&lt;Future&lt;int&gt;&gt;(() async {      try {        await runner.run(args);        return await _exit(0);      } catch (error, stackTrace) {      }    }, onError: (Object error, StackTrace stackTrace) async {    });  }, overrides: overrides);}</code></pre><h3 id="CommandRunner-runCommand"><a href="#CommandRunner-runCommand" class="headerlink" title="CommandRunner runCommand"></a>CommandRunner runCommand</h3><p>找到FlutterCommandRunner类的文件 flutter_tools\lib\src\runner\flutter_command_runner.dart</p><pre><code class="dart">class FlutterCommandRunner extends CommandRunner&lt;void&gt; {    await context.run&lt;void&gt;(      overrides: contextOverrides.map&lt;Type, Generator&gt;((Type type, dynamic value) {        return MapEntry&lt;Type, Generator&gt;(type, () =&gt; value);      }),      body: () async {        .........省略部分代码........        await super.runCommand(topLevelResults);      },    );  }</code></pre><p>CommandRunner这是命令行调用的类，泛型 T 参数就是代表了 [Command.run] 和 [CommandRunner.run] 返回的类型。如果没有返回值可以忽略 T 。</p><pre><code class="dart">class CommandRunner&lt;T&gt; {  .........省略部分代码........  /// 运行[topLevelResults]指定的命令。  /// 这在理论来讲是受保护的方法。可能被覆盖或从子类调用，但不应该在外部调用。  /// 重写它来处理全局标志或将整个命令封装在块中是很有用的。例如，您可以在这里处理“—verbose”标志，便于在运行命令前启用详细日志记录。  /// 这个返回是[Command.run]的结果。  Future&lt;T&gt; runCommand(ArgResults topLevelResults) async {    var argResults = topLevelResults;    var commands = _commands;    Command command;    var commandString = executableName;    while (commands.isNotEmpty) {      .........省略部分代码........      // 要执行的命令      argResults = argResults.command;      command = commands[argResults.name];// 在commands里面取出run对应的RunCommand对象实例      command._globalResults = topLevelResults;      command._argResults = argResults;      commands = command._subcommands;      commandString += &quot; ${argResults.name}&quot;;      .........省略部分代码........    }    .........省略部分代码........    return (await command.run()) as T; //执行RunCommand.run()  }</code></pre><p>辗转到了这里 \flutter\packages\flutter_tools\lib\src\commands\run.dart ，run 命令就是执行的RunCommand内 HotRunner对象的方法。</p><pre><code class="dart">class RunCommand extends RunCommandBase {  @override  final String name = &#39;run&#39;;  List&lt;Device&gt; devices; .........省略部分代码........ bool shouldUseHotMode() {    final bool hotArg = argResults[&#39;hot&#39;] ?? false;    final bool shouldUseHotMode = hotArg &amp;&amp; !traceStartup;    return getBuildInfo().isDebug &amp;&amp; shouldUseHotMode;  }  @override  Future&lt;FlutterCommandResult&gt; runCommand() async {    Cache.releaseLockEarly();    // debug 模式下会默认开启热加载模式，如果不用热加载模式，可以使用--no-hot参数关闭它。    final bool hotMode = shouldUseHotMode();    .........省略部分代码........    final List&lt;FlutterDevice&gt; flutterDevices = &lt;FlutterDevice&gt;[];//    final FlutterProject flutterProject = FlutterProject.current();    for (Device device in devices) { // 遍历出来所有支持的Flutter设备      final FlutterDevice flutterDevice = await FlutterDevice.create(        device,        flutterProject: flutterProject,        trackWidgetCreation: argResults[&#39;track-widget-creation&#39;],        fileSystemRoots: argResults[&#39;filesystem-root&#39;],        fileSystemScheme: argResults[&#39;filesystem-scheme&#39;],        viewFilter: argResults[&#39;isolate-filter&#39;],        experimentalFlags: expFlags,        target: argResults[&#39;target&#39;],        buildMode: getBuildMode(),      );      flutterDevices.add(flutterDevice);    }    ResidentRunner runner;    final String applicationBinaryPath = argResults[&#39;use-application-binary&#39;];    if (hotMode &amp;&amp; !webMode) {// 这里开始构建热加载模式的HotRunner啦      runner = HotRunner(        flutterDevices,        target: targetFile,        debuggingOptions: _createDebuggingOptions(),        benchmarkMode: argResults[&#39;benchmark&#39;],        applicationBinary: applicationBinaryPath == null            ? null            : fs.file(applicationBinaryPath),        projectRootPath: argResults[&#39;project-root&#39;],        packagesFilePath: globalResults[&#39;packages&#39;],        dillOutputPath: argResults[&#39;output-dill&#39;],        stayResident: stayResident,        ipv6: ipv6,      );    } else if (webMode) { //web 模式下的runner 工厂构建       .........省略部分代码........    } else {      .........省略部分代码........    }    // 以热加载模式执行run方法    final int result = await runner.run(      appStartedCompleter: appStartedTimeRecorder,      route: route,    );      //返回执行的结果    return FlutterCommandResult(      ExitStatus.success,      timingLabelParts: &lt;String&gt;[        hotMode ? &#39;hot&#39; : &#39;cold&#39;,        getModeName(getBuildMode()),        devices.length == 1            ? getNameForTargetPlatform(await devices[0].targetPlatform)            : &#39;multiple&#39;,        devices.length == 1 &amp;&amp; await devices[0].isLocalEmulator ? &#39;emulator&#39; : null,      ],      endTimeOverride: appStartedTime,    );  }}</code></pre><h3 id="HotRunner-run"><a href="#HotRunner-run" class="headerlink" title="HotRunner run"></a>HotRunner run</h3><p>以热加载模式执行run方法 , \flutter\packages\flutter_tools\lib\src\run_hot.dart</p><pre><code class="dart">class HotRunner extends ResidentRunner {.........省略部分代码........@override  Future&lt;int&gt; run({    Completer&lt;DebugConnectionInfo&gt; connectionInfoCompleter,    Completer&lt;void&gt; appStartedCompleter,    String route,  }) async {    .........省略部分代码........    firstBuildTime = DateTime.now();    for (FlutterDevice device in flutterDevices) {        // 运行热加载      final int result = await device.runHot(        hotRunner: this,        route: route,      );      if (result != 0) {        return result;      }    }// 在开发者侧发起连接请求，建立Socket远程连接    return attach(      connectionInfoCompleter: connectionInfoCompleter,      appStartedCompleter: appStartedCompleter,    );  }</code></pre><h3 id="sendRequest"><a href="#sendRequest" class="headerlink" title="sendRequest"></a>sendRequest</h3><p>发起请求Request连接设备</p><pre><code class="dart">/// 发送JSON-RPC 2请求来调用给定的[method]。/// 传递的方法参数必须是[Iterable](按位置传递参数)或[Map](按名称传递参数)。不管哪种方式，都必须是JSON-serializable。///如果请求成功，会返回经过解码的JSON-serializable对象的响应结果。如果失败，它将抛出一个描述失败的异常[RpcException]。/// 如果在请求运行时或调用此方法时，客户机被关闭了，就会抛出错误[StateError]。Future sendRequest(String method, [parameters]) {    var id = _id++;    _send(method, parameters, id);    var completer = new Completer.sync();    _pendingRequests[id] = new _Request(method, completer, new Chain.current());    return completer.future;  }</code></pre><h3 id="runHot"><a href="#runHot" class="headerlink" title="runHot"></a>runHot</h3><p>运行热加载</p><pre><code class="dart">Future&lt;int&gt; runHot({HotRunner hotRunner,String route,}) async {    final bool prebuiltMode = hotRunner.applicationBinary != null;  // 判断是否是预编译模式    final String modeName = hotRunner.debuggingOptions.buildInfo.friendlyModeName;// debug模式    printStatus(&#39;Launching ${getDisplayPath(hotRunner.mainPath)} on ${device.name} in $modeName mode...&#39;);    final TargetPlatform targetPlatform = await device.targetPlatform;  // 设备的平台架构    // 应用的对象    package = await ApplicationPackageFactory.instance.getPackageForPlatform(      targetPlatform,      applicationBinary: hotRunner.applicationBinary,    );    final Map&lt;String, dynamic&gt; platformArgs = &lt;String, dynamic&gt;{};    // 启动应用程序    final Future&lt;LaunchResult&gt; futureResult = device.startApp(      package,      mainPath: hotRunner.mainPath,      debuggingOptions: hotRunner.debuggingOptions,      platformArgs: platformArgs,      route: route,      prebuiltApplication: prebuiltMode,      usesTerminalUi: hotRunner.usesTerminalUi,      ipv6: hotRunner.ipv6,    );    final LaunchResult result = await futureResult;    if (!result.started) {      printError(&#39;Error launching application on ${device.name}.&#39;);      await stopEchoingDeviceLog();      return 2;    }    if (result.hasObservatory) {      observatoryUris = &lt;Uri&gt;[result.observatoryUri];    } else {      observatoryUris = &lt;Uri&gt;[];    }    return 0;  }</code></pre><h3 id="getPackageForPlatform"><a href="#getPackageForPlatform" class="headerlink" title="getPackageForPlatform"></a>getPackageForPlatform</h3><p>根据平台相应创建不同的对象，平台包括：Android、iOS、tester、darwin、web、linux、Windows、Fuchsia</p><pre><code class="dart">class ApplicationPackageFactory {  static ApplicationPackageFactory get instance =&gt; context.get&lt;ApplicationPackageFactory&gt;();  Future&lt;ApplicationPackage&gt; getPackageForPlatform(    TargetPlatform platform, {    File applicationBinary,  }) async {    switch (platform) {      case TargetPlatform.android_arm:      case TargetPlatform.android_arm64:      case TargetPlatform.android_x64:      case TargetPlatform.android_x86:        if (androidSdk?.licensesAvailable == true  &amp;&amp; androidSdk.latestVersion == null) {          await checkGradleDependencies();        }       // FlutterProject.current().android 就是当前flutter工程项目中的android子项目        return applicationBinary == null            ? await AndroidApk.fromAndroidProject(FlutterProject.current().android)            : AndroidApk.fromApk(applicationBinary);      case TargetPlatform.ios:        return applicationBinary == null            ? IOSApp.fromIosProject(FlutterProject.current().ios)            : IOSApp.fromPrebuiltApp(applicationBinary);      case TargetPlatform.tester:        return FlutterTesterApp.fromCurrentDirectory();      case TargetPlatform.darwin_x64:        return applicationBinary == null            ? MacOSApp.fromMacOSProject(FlutterProject.current().macos)            : MacOSApp.fromPrebuiltApp(applicationBinary);      case TargetPlatform.web_javascript:        if (!FlutterProject.current().web.existsSync()) {          return null;        }        return WebApplicationPackage(FlutterProject.current());      case TargetPlatform.linux_x64:        return applicationBinary == null            ? LinuxApp.fromLinuxProject(FlutterProject.current().linux)            : LinuxApp.fromPrebuiltApp(applicationBinary);      case TargetPlatform.windows_x64:        return applicationBinary == null            ? WindowsApp.fromWindowsProject(FlutterProject.current().windows)            : WindowsApp.fromPrebuiltApp(applicationBinary);      case TargetPlatform.fuchsia:        return applicationBinary == null            ? FuchsiaApp.fromFuchsiaProject(FlutterProject.current().fuchsia)            : FuchsiaApp.fromPrebuiltApp(applicationBinary);    }    assert(platform != null);    return null;  }}</code></pre><h3 id="fromAndroidProject"><a href="#fromAndroidProject" class="headerlink" title="fromAndroidProject"></a>fromAndroidProject</h3><p>\flutter\packages\flutter_tools\lib\src\application_package.dart</p><pre><code class="dart"> /// 基于Android配置文件创建一个新的AndroidApk对象。  static Future&lt;AndroidApk&gt; fromAndroidProject(AndroidProject androidProject) async {    File apkFile;    if (androidProject.isUsingGradle) {    // 如果是gradle项目，获取apk文件就是在此处执行 Initializing gradle 和 Resolving dependencies 该方法返回build目录中的apk文件路径      apkFile = await getGradleAppOut(androidProject);      if (apkFile.existsSync()) {      //从.apk中获取信息。gradle构建脚本可能会改变应用程序Id，因此我们需要查看实际构建了什么。             return AndroidApk.fromApk(apkFile);      }    } else {//.apk还没有建立起来，所以我们只能利用现有的资源。运行命令将抓取一个新的AndroidApk建设后，以获得更新id。      apkFile = fs.file(fs.path.join(getAndroidBuildDirectory(), &#39;app.apk&#39;));    }    final File manifest = androidProject.appManifestFile;    ....省略部分代码.....    // 这里主要是读取apk文件内的Androidmanifest xml文件最后构建AndroidApk    final String manifestString = manifest.readAsStringSync();    xml.XmlDocument document;    try {      document = xml.parse(manifestString);    }    ....省略部分代码.....    return AndroidApk(      id: packageId,      file: apkFile,      versionCode: null,      launchActivity: launchActivity,    );  }</code></pre><pre><code class="dart">/// 依赖存在的APK，创建一个新的AndroidApk对象。  factory AndroidApk.fromApk(File apk) {    final String aaptPath = androidSdk?.latestVersion?.aaptPath;    if (aaptPath == null) {      printError(userMessages.aaptNotFound);      return null;    }//aapt 工具 dump &#39;AndroidManifest.xml&#39;文件的 xml树结构    String apptStdout;    try {      apptStdout = runCheckedSync(&lt;String&gt;[        aaptPath,        &#39;dump&#39;,        &#39;xmltree&#39;,        apk.path,        &#39;AndroidManifest.xml&#39;,      ]);    } catch (error) {      printError(&#39;Failed to extract manifest from APK: $error.&#39;);      return null;    }    final ApkManifestData data = ApkManifestData.parseFromXmlDump(apptStdout);....省略部分代码.....    return AndroidApk(      id: data.packageName,      file: apk,      versionCode: int.tryParse(data.versionCode),      launchActivity: &#39;${data.packageName}/${data.launchableActivityName}&#39;,    );  }</code></pre><h3 id="AndroidDevice-startApp"><a href="#AndroidDevice-startApp" class="headerlink" title="AndroidDevice startApp"></a>AndroidDevice startApp</h3><p>由 AndroidDevice startApp，此时来到Android平台下的AndroidDevice类所在的文件，路径\flutter\packages\flutter_tools\lib\src\android\android_device.dart</p><pre><code class="dart">class AndroidDevice extends Device {....省略部分代码....  @override  Future&lt;LaunchResult&gt; startApp(    ApplicationPackage package, {    String mainPath,    String route,    DebuggingOptions debuggingOptions,    Map&lt;String, dynamic&gt; platformArgs,    bool prebuiltApplication = false,    bool ipv6 = false,    bool usesTerminalUi = true,  }) async {    if (!await _checkForSupportedAdbVersion() || !await _checkForSupportedAndroidVersion())      return LaunchResult.failed();    final TargetPlatform devicePlatform = await targetPlatform;    //检查架构信息是否支持    if (!(devicePlatform == TargetPlatform.android_arm ||          devicePlatform == TargetPlatform.android_arm64) &amp;&amp;        !debuggingOptions.buildInfo.isDebug) {      printError(&#39;Profile and release builds are only supported on ARM targets.&#39;);      return LaunchResult.failed();    }    AndroidArch androidArch;    switch (devicePlatform) {      case TargetPlatform.android_arm:        androidArch = AndroidArch.armeabi_v7a;        break;      case TargetPlatform.android_arm64:        androidArch = AndroidArch.arm64_v8a;        break;      case TargetPlatform.android_x64:        androidArch = AndroidArch.x86_64;        break;      case TargetPlatform.android_x86:        androidArch = AndroidArch.x86;        break;      default:        printError(&#39;Android platforms are only supported.&#39;);        return LaunchResult.failed();    }    if (!prebuiltApplication || androidSdk.licensesAvailable &amp;&amp; androidSdk.latestVersion == null) {      printTrace(&#39;Building APK&#39;);      final FlutterProject project = FlutterProject.current();      // assembleDebug 开始构建APK      await buildApk(          project: project,          target: mainPath,          androidBuildInfo: AndroidBuildInfo(debuggingOptions.buildInfo,            targetArchs: &lt;AndroidArch&gt;[androidArch]          ),      );      // APK 包已经构建完成，这时候可以从apk文件更新Application ID和Activity 名称      package = await AndroidApk.fromAndroidProject(project.android);    }    // 解析失败，抛出异常,退出编译    if (package == null) {      throwToolExit(&#39;Problem building Android application: see above error(s).&#39;);    }    await stopApp(package);// 运行adb install 命令来安装上面生成的Apk文件。这里下面会有调用方法讲解，其实就是调用了adb install命令。    if (!await _installLatestApp(package))      return LaunchResult.failed();    ......省略部分代码.......    List&lt;String&gt; cmd;    cmd = &lt;String&gt;[      &#39;shell&#39;, &#39;am&#39;, &#39;start&#39;,      &#39;-a&#39;, &#39;android.intent.action.RUN&#39;,      &#39;-f&#39;, &#39;0x20000000&#39;, // FLAG_ACTIVITY_SINGLE_TOP      &#39;--ez&#39;, &#39;enable-background-compilation&#39;, &#39;true&#39;,      &#39;--ez&#39;, &#39;enable-dart-profiling&#39;, &#39;true&#39;,      if (traceStartup)        ...&lt;String&gt;[&#39;--ez&#39;, &#39;trace-startup&#39;, &#39;true&#39;],      if (route != null)        ...&lt;String&gt;[&#39;--es&#39;, &#39;route&#39;, route],      if (debuggingOptions.enableSoftwareRendering)        ...&lt;String&gt;[&#39;--ez&#39;, &#39;enable-software-rendering&#39;, &#39;true&#39;],      if (debuggingOptions.skiaDeterministicRendering)        ...&lt;String&gt;[&#39;--ez&#39;, &#39;skia-deterministic-rendering&#39;, &#39;true&#39;],      if (debuggingOptions.traceSkia)        ...&lt;String&gt;[&#39;--ez&#39;, &#39;trace-skia&#39;, &#39;true&#39;],      if (debuggingOptions.traceSystrace)        ...&lt;String&gt;[&#39;--ez&#39;, &#39;trace-systrace&#39;, &#39;true&#39;],      if (debuggingOptions.dumpSkpOnShaderCompilation)        ...&lt;String&gt;[&#39;--ez&#39;, &#39;dump-skp-on-shader-compilation&#39;, &#39;true&#39;],      if (debuggingOptions.debuggingEnabled)        ...&lt;String&gt;[          if (debuggingOptions.buildInfo.isDebug)            ...&lt;String&gt;[              ...&lt;String&gt;[&#39;--ez&#39;, &#39;enable-checked-mode&#39;, &#39;true&#39;],              ...&lt;String&gt;[&#39;--ez&#39;, &#39;verify-entry-points&#39;, &#39;true&#39;],            ],          if (debuggingOptions.startPaused)            ...&lt;String&gt;[&#39;--ez&#39;, &#39;start-paused&#39;, &#39;true&#39;],          if (debuggingOptions.disableServiceAuthCodes)            ...&lt;String&gt;[&#39;--ez&#39;, &#39;disable-service-auth-codes&#39;, &#39;true&#39;],          if (debuggingOptions.dartFlags.isNotEmpty)            ...&lt;String&gt;[&#39;--es&#39;, &#39;dart-flags&#39;, debuggingOptions.dartFlags],          if (debuggingOptions.useTestFonts)            ...&lt;String&gt;[&#39;--ez&#39;, &#39;use-test-fonts&#39;, &#39;true&#39;],          if (debuggingOptions.verboseSystemLogs)            ...&lt;String&gt;[&#39;--ez&#39;, &#39;verbose-logging&#39;, &#39;true&#39;],        ],      apk.launchActivity,//cmd 命令 启动Activity    ];    final String result = (await runAdbCheckedAsync(cmd)).stdout;    // 即使调用失败，也会返回0。    if (result.contains(&#39;Error: &#39;)) {      printError(result.trim(), wrap: false);      return LaunchResult.failed();    }    if (!debuggingOptions.debuggingEnabled)      return LaunchResult.succeeded(); //Activity启动成功    try {      Uri observatoryUri;      if (debuggingOptions.buildInfo.isDebug || debuggingOptions.buildInfo.isProfile) {        observatoryUri = await observatoryDiscovery.uri;      }      return LaunchResult.succeeded(observatoryUri: observatoryUri);    } catch (error) {      printError(&#39;Error waiting for a debug connection: $error&#39;);      return LaunchResult.failed();    } finally {      await observatoryDiscovery.cancel();    }  }</code></pre><h3 id="startApp-apk-buildApk"><a href="#startApp-apk-buildApk" class="headerlink" title="startApp apk buildApk"></a>startApp apk buildApk</h3><p>\flutter\packages\flutter_tools\lib\src\android\apk.dart</p><pre><code class="dart">Future&lt;void&gt; buildApk({  @required FlutterProject project,  @required String target,  @required AndroidBuildInfo androidBuildInfo,}) async {  ....省略部分代码.....  //调用Gradle脚本，构建Android 工程  await buildGradleProject(    project: project,    androidBuildInfo: androidBuildInfo,    target: target,    isBuildingBundle: false,  );  androidSdk.reinitialize();}</code></pre><h3 id="startApp-installApp"><a href="#startApp-installApp" class="headerlink" title="startApp installApp"></a>startApp installApp</h3><p>\flutter\packages\flutter_tools\lib\src\android\android_device.dart</p><pre><code> @override  Future&lt;bool&gt; installApp(ApplicationPackage app) async {    final AndroidApk apk = app;     ....省略部分代码.....     // 这里执行了adb install 命令    final RunResult installResult = await runAsync(adbCommandForDevice(&lt;String&gt;[&#39;install&#39;, &#39;-t&#39;, &#39;-r&#39;, apk.file.path]));     ....省略部分代码.....    return true;  }</code></pre><p>至此，Android apk 就被启动起来了，好像是少了些什么？Flutter 资源方面是如何被编译处理打包进去的呢？</p><p>翻源码目录，在这个文件gradle/flutter.gradle下，应用了插件 FlutterPlugin</p><h2 id="FlutterPlugin"><a href="#FlutterPlugin" class="headerlink" title="FlutterPlugin"></a>FlutterPlugin</h2><p>\flutter\packages\flutter_tools\gradle\flutter.gradle</p><pre><code class="groovy">apply plugin: FlutterPlugin@Override    void apply(Project project) {        // flutter 工程配置        project.extensions.create(&quot;flutter&quot;, FlutterExtension)        // 添加 flutterTask，编译操作就在这个任务内        project.afterEvaluate this.&amp;addFlutterTasks        String flutterRootPath = resolveProperty(project, &quot;flutter.sdk&quot;, System.env.FLUTTER_ROOT)        if (flutterRootPath == null) {            throw new GradleException(&quot;没发现FlutterSDK. 定义一下local.properties的SDK路径或配一下系统环境变量FLUTTER_ROOT.&quot;)        }        flutterRoot = project.file(flutterRootPath)        if (!flutterRoot.isDirectory()) {            throw new GradleException(&quot;flutter.sdk must point to the Flutter SDK directory&quot;)        }        String flutterExecutableName = Os.isFamily(Os.FAMILY_WINDOWS) ? &quot;flutter.bat&quot; : &quot;flutter&quot;        flutterExecutable = Paths.get(flutterRoot.absolutePath, &quot;bin&quot;, flutterExecutableName).toFile();// 配置了本地自己编译的引擎目录         if (useLocalEngine(project)) {            String engineOutPath = project.property(&#39;localEngineOut&#39;)            File engineOut = project.file(engineOutPath)            if (!engineOut.isDirectory()) {                throw new GradleException(&#39;localEngineOut must point to a local engine build&#39;)            }            Path baseEnginePath = Paths.get(engineOut.absolutePath)            flutterJar = baseEnginePath.resolve(&quot;flutter.jar&quot;).toFile()            if (!flutterJar.isFile()) {                throw new GradleException(&quot;本地引擎没有发现: $flutterJar&quot;)            }            localEngine = engineOut.name            localEngineSrcPath = engineOut.parentFile.parent            // 本地引擎是为其中一种构建类型构建的。            // 无论如何，每个构建的类型都用同样的引擎.            project.android.buildTypes.each {                addApiDependencies(project, it.name, project.files {                    flutterJar                })            }        } else {// 找到flutter engine目录，这里面有已经编译好的所有平台架构所有build type的flutter engine。            String basePlatformArch = getBasePlatform(project)// 这意味着只包含编译后的类，但是它将包含&#39;libflutter.so&#39;            Path baseEnginePath = Paths.get(flutterRoot.absolutePath, &quot;bin&quot;, &quot;cache&quot;, &quot;artifacts&quot;, &quot;engine&quot;)// Android平台提供的是一个jar包，flutter.jar，在这个jar包中包含了engine so库，和Java Api库。            File debugJar = baseEnginePath.resolve(&quot;${basePlatformArch}&quot;)            .resolve(&quot;flutter.jar&quot;).toFile()            baseJar[&quot;debug&quot;] = debugJar            if (!debugJar.isFile()) {                project.exec {                    executable flutterExecutable.absolutePath                    args &quot;--suppress-analytics&quot;                    args &quot;precache&quot;                }                if (!debugJar.isFile()) {                    throw new GradleException(&quot;Unable to find flutter.jar in SDK: ${debugJar}&quot;)                }            }            baseJar[&quot;profile&quot;] = baseEnginePath.resolve(&quot;${basePlatformArch}-profile&quot;).resolve(&quot;flutter.jar&quot;).toFile()            baseJar[&quot;release&quot;] = baseEnginePath.resolve(&quot;${basePlatformArch}-release&quot;).resolve(&quot;flutter.jar&quot;).toFile()            //向所有 Api 配置添加 flutter.jar 依赖项，包括应用 Flutter 插件后添加的自定义依赖项。            project.android.buildTypes.each {                def buildMode = buildModeFor(it)                addApiDependencies(project, it.name, project.files {                    baseJar[buildMode]                })            }            project.android.buildTypes.whenObjectAdded {                def buildMode = buildModeFor(it)                addApiDependencies(project, it.name, project.files {                    baseJar[buildMode]                })            }        }    }</code></pre><h3 id="addFlutterTasks"><a href="#addFlutterTasks" class="headerlink" title="addFlutterTasks"></a>addFlutterTasks</h3><pre><code class="groovy"> private void addFlutterTasks(Project project) {....省略部分代码.....        String target = project.flutter.target        if (target == null) {// 设置 target            target = &#39;lib/main.dart&#39; //这里就是Flutter的入口路径        }        if (project.hasProperty(&#39;target&#39;)) {            target = project.property(&#39;target&#39;)        }        String[] fileSystemRootsValue = null        if (project.hasProperty(&#39;filesystem-roots&#39;)) {            fileSystemRootsValue = project.property(&#39;filesystem-roots&#39;).split(&#39;\\|&#39;)        }        String fileSystemSchemeValue = null        if (project.hasProperty(&#39;filesystem-scheme&#39;)) {            fileSystemSchemeValue = project.property(&#39;filesystem-scheme&#39;)        }        Boolean trackWidgetCreationValue = false        if (project.hasProperty(&#39;track-widget-creation&#39;)) {            trackWidgetCreationValue = project.property(&#39;track-widget-creation&#39;).toBoolean()        }        String compilationTraceFilePathValue = null        if (project.hasProperty(&#39;compilation-trace-file&#39;)) {            compilationTraceFilePathValue = project.property(&#39;compilation-trace-file&#39;)        }        Boolean createPatchValue = false        if (project.hasProperty(&#39;patch&#39;)) {            createPatchValue = project.property(&#39;patch&#39;).toBoolean()        }        Integer buildNumberValue = null        if (project.hasProperty(&#39;build-number&#39;)) {            buildNumberValue = project.property(&#39;build-number&#39;).toInteger()        }        String baselineDirValue = null        if (project.hasProperty(&#39;baseline-dir&#39;)) {            baselineDirValue = project.property(&#39;baseline-dir&#39;)        }        String extraFrontEndOptionsValue = null        if (project.hasProperty(&#39;extra-front-end-options&#39;)) {            extraFrontEndOptionsValue = project.property(&#39;extra-front-end-options&#39;)        }        String extraGenSnapshotOptionsValue = null        if (project.hasProperty(&#39;extra-gen-snapshot-options&#39;)) {            extraGenSnapshotOptionsValue = project.property(&#39;extra-gen-snapshot-options&#39;)        }        def targetPlatforms = getTargetPlatforms(project)        def addFlutterDeps = { variant -&gt;            if (splitPerAbi(project)) {                variant.outputs.each { output -&gt;//将新版本代码分配给 versionCodeOverride，它将更改版本代码只针对输出APK，而不是变量本身。//简单地跳过这一步使Gradle使用变量的值。APK的版本代码。//更多信息，请参见https://developer.android.com/studio/build/configu-apk -split                def abiVersionCode = ABI_VERSION.get(output.getFilter(OutputFile.ABI))                    if (abiVersionCode != null) {                        output.versionCodeOverride =                            abiVersionCode * 1000 + variant.versionCode                    }                }            }// 配置flutter命令运行参数            String flutterBuildMode = buildModeFor(variant.buildType)            if (flutterBuildMode == &#39;debug&#39; &amp;&amp; project.tasks.findByName(&quot;${FLUTTER_BUILD_PREFIX}X86Jar&quot;)) {              Task task = project.tasks.findByName(&quot;compile${variant.name.capitalize()}JavaWithJavac&quot;)                if (task) {  // 如果是debug模式，X86架构的任务添加到javac编译任务上。                    task.dependsOn project.flutterBuildX86Jar                }                task = project.tasks.findByName(&quot;compile${variant.name.capitalize()}Kotlin&quot;)                if (task) {   //kotlin项目                    task.dependsOn project.flutterBuildX86Jar                }            }            def compileTasks = targetPlatforms.collect { targetArch -&gt;                String abiValue = PLATFORM_ARCH_MAP[targetArch]                String taskName = toCammelCase([&quot;compile&quot;, FLUTTER_BUILD_PREFIX, variant.name, targetArch.replace(&#39;android-&#39;, &#39;&#39;)])                // 创建 Flutter 任务                FlutterTask compileTask = project.tasks.create(name: taskName, type: FlutterTask) {                    flutterRoot this.flutterRoot                    flutterExecutable this.flutterExecutable                    buildMode flutterBuildMode                    localEngine this.localEngine                    localEngineSrcPath this.localEngineSrcPath                    abi abiValue                    targetPath target                    verbose isVerbose(project)                    fileSystemRoots fileSystemRootsValue                    fileSystemScheme fileSystemSchemeValue                    trackWidgetCreation trackWidgetCreationValue                    compilationTraceFilePath compilationTraceFilePathValue                    createPatch createPatchValue                    buildNumber buildNumberValue                    baselineDir baselineDirValue                    targetPlatform targetArch                    sourceDir project.file(project.flutter.source)                    intermediateDir project.file(&quot;${project.buildDir}/${AndroidProject.FD_INTERMEDIATES}/flutter/${variant.name}/${targetArch}&quot;)                    extraFrontEndOptions extraFrontEndOptionsValue                    extraGenSnapshotOptions extraGenSnapshotOptionsValue                }            }            def libJar = project.file(&quot;${project.buildDir}/${AndroidProject.FD_INTERMEDIATES}/flutter/${variant.name}/libs.jar&quot;)            def libFlutterPlatforms = targetPlatforms.collect()            // x86/x86_64 原生库仅在debug模式下使用.            if (flutterBuildMode == &#39;debug&#39;) {                libFlutterPlatforms.add(&#39;android-x86&#39;)                libFlutterPlatforms.add(&#39;android-x64&#39;)            }            Task packFlutterSnapshotsAndLibsTask = project.tasks.create(name: &quot;packLibs${FLUTTER_BUILD_PREFIX}${variant.name.capitalize()}&quot;, type: Jar) {                destinationDir libJar.parentFile                archiveName libJar.name                libFlutterPlatforms.each { targetArch -&gt;//这个二次检查防止包含&#39;libflutter.so&#39;，它包含在基础平台 lib.jar 中。//很不幸的是，“packagingOptions”中的“pickFirst”设置不起作用。当项目“:flutter”被包含作为实现依赖项时，会导致重复的“libflutter.so”。 “libflutter.so”文件通常根据不同架构打入lib.jar中。                    if (getBasePlatform(project) == targetArch) {                        return                    }                    // 当指定了本地引擎时,其他架构不包括“libflutter.so“。                    if (useLocalEngine(project)) {                        return                    }                    def engineArtifactSubdir = getEngineArtifactDirName(variant.buildType, targetArch);                    // 包含 `libflutter.so`.             from(project.zipTree(&quot;${flutterRoot}/bin/cache/artifacts/engine/${engineArtifactSubdir}/flutter.jar&quot;)) {                        include &#39;lib/**&#39;                    }                }                dependsOn compileTasks                // 添加 ELF 库.                compileTasks.each { compileTask -&gt;                    from(compileTask.intermediateDir) {                        include &#39;*.so&#39;                        rename { String filename -&gt;                            return &quot;lib/${compileTask.abi}/lib${filename}&quot;                        }                    }                }            }            // 在`lib/`目录，包括快照和文件libflutter.so            addApiDependencies(project, variant.name, project.files {                packFlutterSnapshotsAndLibsTask            })            // 我们知道当这些任务存在时，flutter应用程序是Android应用程序中的子项目。            Task packageAssets = project.tasks.findByPath(&quot;:flutter:package${variant.name.capitalize()}Assets&quot;)            Task cleanPackageAssets = project.tasks.findByPath(&quot;:flutter:cleanPackage${variant.name.capitalize()}Assets&quot;)            Task copyFlutterAssetsTask = project.tasks.create(name: &quot;copyFlutterAssets${variant.name.capitalize()}&quot;, type: Copy) {                dependsOn compileTasks                if (packageAssets &amp;&amp; cleanPackageAssets) {                    dependsOn packageAssets                    dependsOn cleanPackageAssets                    into packageAssets.outputDir                } else {                    dependsOn variant.mergeAssets                    dependsOn &quot;clean${variant.mergeAssets.name.capitalize()}&quot;                    variant.mergeAssets.mustRunAfter(&quot;clean${variant.mergeAssets.name.capitalize()}&quot;)                    into variant.mergeAssets.outputDir                }                compileTasks.each { flutterTask -&gt;                    with flutterTask.assets                }            }            variant.outputs.first().processResources.dependsOn(copyFlutterAssetsTask)        }        if (project.android.hasProperty(&quot;applicationVariants&quot;)) {            project.android.applicationVariants.all addFlutterDeps        } else {            project.android.libraryVariants.all addFlutterDeps        }        if (buildPluginAsAar()) {            addPluginTasks(project)            List&lt;String&gt; tasksToExecute = project.gradle.startParameter.taskNames            Set buildTypes = getBuildTypesForTasks(project, tasksToExecute)            if (tasksToExecute.contains(&quot;clean&quot;)) {                // 由于插件是在配置期间构建的，任务“clean”不能与组装任务一起运行。                if (!buildTypes.empty) {                    throw new GradleException(&quot;不能运行clean任务和其他assemble任务&quot;)                }            }            // 在稍后调用任务“assembly*”时构建插件。            if (!buildTypes.empty) {                // 在配置期间构建插件。                // 启用Jetifier时需要这样做，否则无法添加实现依赖项。                buildPlugins(project, buildTypes)            }        } else {            getPluginList(project).each { name, _ -&gt;                def pluginProject = project.rootProject.findProject(&quot;:$name&quot;)                if (pluginProject != null) {                    project.dependencies {                        if (project.getConfigurations().findByName(&quot;implementation&quot;)) {                            implementation pluginProject                        } else {                            compile pluginProject                        }                    }                    pluginProject.afterEvaluate {                        pluginProject.android.buildTypes {                            profile {                                initWith debug                            }                        }                        pluginProject.android.buildTypes.each {                            def buildMode = buildModeFor(it)                            addFlutterJarCompileOnlyDependency(pluginProject, it.name, project.files( flutterJar ?: baseJar[buildMode] ))                        }                        pluginProject.android.buildTypes.whenObjectAdded {                            def buildMode = buildModeFor(it)                            addFlutterJarCompileOnlyDependency(pluginProject, it.name, project.files( flutterJar ?: baseJar[buildMode] ))                        }                    }                } else {                    project.logger.error(&quot;Plugin project :$name not found. Please update settings.gradle.&quot;)                }            }        }    }</code></pre><h3 id="buildBundle"><a href="#buildBundle" class="headerlink" title="buildBundle"></a>buildBundle</h3><p>flutterTask 编译 dart 资源</p><pre><code class="groovy">void buildBundle() {        if (!sourceDir.isDirectory()) {            throw new GradleException(&quot;无效的Flutter资源目录: ${sourceDir}&quot;)        }        intermediateDir.mkdirs()        if (buildMode == &quot;profile&quot; || buildMode == &quot;release&quot;) {            project.exec {                executable flutterExecutable.absolutePath                workingDir sourceDir                if (localEngine != null) {                    args &quot;--local-engine&quot;, localEngine                    args &quot;--local-engine-src-path&quot;, localEngineSrcPath                }                args &quot;build&quot;, &quot;aot&quot;                args &quot;--suppress-analytics&quot;                args &quot;--quiet&quot;                args &quot;--target&quot;, targetPath                args &quot;--output-dir&quot;, &quot;${intermediateDir}&quot;                args &quot;--target-platform&quot;, &quot;${targetPlatform}&quot;                if (trackWidgetCreation) {                    args &quot;--track-widget-creation&quot;                }                if (extraFrontEndOptions != null) {                    args &quot;--extra-front-end-options&quot;, &quot;${extraFrontEndOptions}&quot;                }                if (extraGenSnapshotOptions != null) {                    args &quot;--extra-gen-snapshot-options&quot;, &quot;${extraGenSnapshotOptions}&quot;                }                args &quot;--${buildMode}&quot;            }        }        project.exec {            executable flutterExecutable.absolutePath // executable 就是flutter命令            workingDir sourceDir // dart代码目录            if (localEngine != null) { // 可以配置本地引擎                args &quot;--local-engine&quot;, localEngine                args &quot;--local-engine-src-path&quot;, localEngineSrcPath            }            // 配置flutter 命令参数，执行的是flutter build bundle 来编译dart代码。            args &quot;build&quot;, &quot;bundle&quot;            args &quot;--target&quot;, targetPath            args &quot;--target-platform&quot;, &quot;${targetPlatform}&quot;            if (verbose) {                args &quot;--verbose&quot;            }            if (fileSystemRoots != null) {                for (root in fileSystemRoots) {                    args &quot;--filesystem-root&quot;, root                }            }            if (fileSystemScheme != null) {                args &quot;--filesystem-scheme&quot;, fileSystemScheme            }            if (trackWidgetCreation) {                args &quot;--track-widget-creation&quot;            }            if (compilationTraceFilePath != null) {                args &quot;--compilation-trace-file&quot;, compilationTraceFilePath            }            if (createPatch) {                args &quot;--patch&quot;                args &quot;--build-number&quot;, project.android.defaultConfig.versionCode                if (buildNumber != null) {                    assert buildNumber == project.android.defaultConfig.versionCode                }            }            if (baselineDir != null) {                args &quot;--baseline-dir&quot;, baselineDir            }            if (extraFrontEndOptions != null) {                args &quot;--extra-front-end-options&quot;, &quot;${extraFrontEndOptions}&quot;            }            if (extraGenSnapshotOptions != null) {                args &quot;--extra-gen-snapshot-options&quot;, &quot;${extraGenSnapshotOptions}&quot;            }            if (buildMode == &quot;release&quot; || buildMode == &quot;profile&quot;) {                args &quot;--precompiled&quot;            } else {                args &quot;--depfile&quot;, &quot;${intermediateDir}/snapshot_blob.bin.d&quot;            }            args &quot;--asset-dir&quot;, &quot;${intermediateDir}/flutter_assets&quot;            if (buildMode == &quot;debug&quot;) {                args &quot;--debug&quot;            }            if (buildMode == &quot;profile&quot;) {                args &quot;--profile&quot;            }            if (buildMode == &quot;release&quot;) {                args &quot;--release&quot;            }        }    }</code></pre><h3 id="编译dart代码"><a href="#编译dart代码" class="headerlink" title="编译dart代码"></a>编译dart代码</h3><p>flutterTask 中会执行 flutter build bundle 来编译 dart 代码。有关于 flutter build bundle 的介绍后面另起一篇，敬请期待。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>针对 Android 平台 flutter run 流程做一个比较细致的介绍。跨平台技术还是要根据不同平台调用不同的脚本。分久必合合久必分。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter dartio 库</title>
    <link href="/2019/08/16/Flutter%20dartio%20%E5%BA%93/"/>
    <url>/2019/08/16/Flutter%20dartio%20%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Flutter-dart-io-库"><a href="#Flutter-dart-io-库" class="headerlink" title="Flutter dart:io 库"></a>Flutter dart:io 库</h1><h3 id="你将得到什么？"><a href="#你将得到什么？" class="headerlink" title="你将得到什么？"></a>你将得到什么？</h3><p>1、dart:io 是什么？</p><p>2、dart:io 使用</p><p>3、dart:io 组成部分</p><p>4、dart:io 总结</p><h2 id="dart-io-是什么"><a href="#dart-io-是什么" class="headerlink" title="dart:io 是什么"></a>dart:io 是什么</h2><p>dart:io 支持对非web应用程序的文件、套接字、HTTP 和其他 I/O 操作。换句话说，不支持基于浏览器的应用程序。只有服务器、命令行脚本和Flutter移动应用程序，才能导入和使用 dart:io 库。</p><p>基于 dart:io 我们可以处理文件、目录、套接字、进程、HTTP 服务器和客户端。使用 Futures 或 Streams 来处理异步的输入和输出相关操作。异步都在 dart:async 库中定义。</p><h2 id="dart-io-使用"><a href="#dart-io-使用" class="headerlink" title="dart:io 使用"></a>dart:io 使用</h2><p>在使用这个库时，将其导入，代码如下：</p><pre><code class="dart">import &#39;dart:io&#39;;</code></pre><h3 id="dart-io-操作文件、目录和连接"><a href="#dart-io-操作文件、目录和连接" class="headerlink" title="dart:io 操作文件、目录和连接"></a>dart:io 操作文件、目录和连接</h3><p>您可以通过这些类型的对象操作文件系统。例如，您可以重命名一个文件或目录:</p><pre><code class="dart">File myFile = new File(&#39;我的文件.txt&#39;);myFile.rename(&#39;新的文件名.txt&#39;).then((_) =&gt; print(&#39;文件被重命名&#39;));</code></pre><p>文件、目录和链接类提供的许多方法，他们都是异步运行的，最后返回一个Future。</p><h3 id="FileSystemEntity"><a href="#FileSystemEntity" class="headerlink" title="FileSystemEntity"></a>FileSystemEntity</h3><p>文件、目录和链接都是FileSystemEntity的扩展。除了作为这些类的超类之外，FileSystemEntity还有许多用于处理路径的静态方法。如“isDirectory”、“isFile”和“exists”等等，来获取文件相关的信息。</p><pre><code class="dart">FileSystemEntity.isDirectory(myPath).then((isDir) {  if (isDir) {    print(&#39;$myPath 是目录&#39;);  } else {    print(&#39;$myPath 不是目录&#39;);  }});</code></pre><h2 id="HttpServer-和-HttpClient"><a href="#HttpServer-和-HttpClient" class="headerlink" title="HttpServer 和 HttpClient"></a>HttpServer 和 HttpClient</h2><p>HttpServer 提供实现 HTTP 服务端的基本功能。</p><p>HttpServer 提供了 HttpRequest 对象的流。每个 HttpRequest 都对应一个 HttpResponse 对象。服务端通过写入 HttpResponse 对象来响应请求。下面代码示例展示如何将HttpServer 绑定到端口 80 上的 IPv6 因特网地址，以及如何侦听请求。</p><pre><code class="dart">import &#39;dart:io&#39;;main() {  HttpServer.bind(InternetAddress.anyIPv6, 80)      .then((server) {        server.listen((HttpRequest request) {          request.response.write(&#39;Hello, world!&#39;);          request.response.close();        });      });}</code></pre><p>对于一些更高级的构建模块，建议尝试一下用于 Dar 的 Web 服务器中间件 <a href="https://pub.dev/packages/shelf">shelf 包</a> ，它包含一组高级类，以及这个库中的 HttpServer 类，更容易实现 HTTP 服务器业务。</p><p>HttpClient 提供客户端的基本功能。</p><pre><code class="dart">HttpClient client = new HttpClient();client.getUrl(Uri.parse(&quot;http://www.example.com/&quot;))    .then((HttpClientRequest request) {     // 可选地设置标题…     // 可选地写入请求对象…     // 然后调用关闭      return request.close();    })    .then((HttpClientResponse response) {      // 处理响应逻辑      ...    });</code></pre><h2 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h2><p>Process 类提供了运行进程的方法。</p><p>例如，下面的代码生成一个进程，递归列出 web 下的文件列表</p><pre><code class="dart">Process.start(&#39;ls&#39;, [&#39;-R&#39;, &#39;web&#39;]).then((process) {  stdout.addStream(process.stdout);  stderr.addStream(process.stderr);  process.exitCode.then(print);});</code></pre><p>调用 start() 方法时返回一个 Future 对象。在运行时，我们是可以操作当前的process，达到想要的目的。另外需要注意在使用 start() 时，必须读取 stdout 和 stderr 流的所有数据，否则系统资源不会被<strong>释放</strong>。</p><pre><code class="dart">// 列出当前目录下的所有文件Process.run(&#39;ls&#39;, [&#39;-l&#39;]).then((ProcessResult results) {  print(results.stdout);});</code></pre><p>调用run方法时，它将以 ProcessResult 对象结束当前进程。run方法不返回进程对象，这的话，我们的代码就不能与当前的process进行交互。</p><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>WebSocket 提供了 web 套接字协议，它支持客户端与服务端的应用程序之间进行全双工通信。web 套接字服务端使用普通 HTTP 来接受套接字连接。初始握手是一个 HTTP 请求，然后升级为 web 套接字连接。服务端使用 WebSocketTransformer 升级请求，并侦听返回的 web 套接字上的数据。例如，这里有一个服务端监听 WebSocket 上的 “ws” 数据:</p><pre><code class="dart">runZoned(() async {  var server = await HttpServer.bind(&#39;127.0.0.1&#39;, 4040);  server.listen((HttpRequest req) async {    if (req.uri.path == &#39;/ws&#39;) {      var socket = await WebSocketTransformer.upgrade(req);      socket.listen(handleMsg);    }  });}, onError: (e) =&gt; print(&quot;An error occurred.&quot;));</code></pre><p>客户端连接示例</p><pre><code>var socket = await WebSocket.connect(&#39;ws://127.0.0.1:4040/ws&#39;);socket.add(&#39;Hello, World!&#39;);</code></pre><p>调用 connect 方法连接到服务端的套接字服务，调用 add 方法往套接字内写入数据。</p><h2 id="ServerSocket-和-Socket"><a href="#ServerSocket-和-Socket" class="headerlink" title="ServerSocket 和 Socket"></a>ServerSocket 和 Socket</h2><p>客户端与服务端基于TCP协议进行通信的。服务端用 ServerSocket ，客户端用 Socket 。服务端的 ServerSocket 调用 bind 创建套接字，然后再监听访问进来的套接字请求。服务端示例：</p><pre><code class="dart">ServerSocket.bind(&#39;127.0.0.1&#39;, 4041)  .then((serverSocket) {    serverSocket.listen((socket) {      socket.transform(utf8.decoder).listen(print);    });  });</code></pre><p>客户端用 connect 方法建立套接字连接，也会返回一个Future。我们可以调用 <code>write()</code>, <code>writeln()</code>,或者 <code>writeAll()</code> 等方法通过套接字发送消息出去。客户端示例：</p><pre><code>Socket.connect(&#39;127.0.0.1&#39;, 4041).then((socket) {  socket.write(&#39;Hello, World!&#39;);});</code></pre><p>除了 Socket 和 ServerSocket 之外，RawSocket 和 RawServerSocket 也可用于对异步套接字IO的低级访问。</p><p>RawSocket 是 TCP 套接字的非缓冲接口。它以与底层操作系统相同的块传输数据流。它不同与<a href="http://man7.org/linux/man-pages/man7/raw.7.html">POSIX</a> 原始套接字，感兴趣可以异步这里了解。</p><h2 id="标准的输出、错误、输入流"><a href="#标准的输出、错误、输入流" class="headerlink" title="标准的输出、错误、输入流"></a>标准的输出、错误、输入流</h2><p>dart:io 库提供了标准的输出、错误和输入流，分别名为 <code>stdout</code>、<code>stderr</code>和<code>stdin</code>。</p><p>stdout 和 stderr 都是从 <a href="https://api.flutter.dev/flutter/dart-io/IOSink-class.html">IOSink</a>s 继承属性和方法。</p><p>stdout 写入字符串：</p><pre><code class="dart">stdout.writeln (“Hello, World !”);</code></pre><p>stderr 写入对象列表:</p><pre><code class="dart">stderr.writeAll([ &#39;That &#39;, &#39;is &#39;, &#39;an &#39;, &#39;error.&#39;, &#39;\n&#39;]);</code></pre><p>stdin 是从 <a href="https://api.flutter.dev/flutter/dart-async/Stream-class.html">Stream 类</a> 继承属性和方法。</p><p>示例命令行同步读取文本：</p><pre><code class="dart">String inputText = stdin.readLineSync();</code></pre><p>一直监听等待用户输入信息。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、牵涉到异步操作的地方，都会返回Future对象。</p><p>2、简单介绍了dart:io，具体在使用时，应详细参考官方每节内容。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter 从加载到显示</title>
    <link href="/2019/08/06/Flutter%E4%BB%8E%E5%8A%A0%E8%BD%BD%E5%88%B0%E6%98%BE%E7%A4%BA/"/>
    <url>/2019/08/06/Flutter%E4%BB%8E%E5%8A%A0%E8%BD%BD%E5%88%B0%E6%98%BE%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="你将会得到什么？"><a href="#你将会得到什么？" class="headerlink" title="你将会得到什么？"></a>你将会得到什么？</h2><p>1、Widget、Element、RenderObject基本概念</p><p>2、在Flutter Framework层从创建到渲染的流程</p><p>3、Flutter在构建布局方面是如何提高效率的</p><h1 id="什么是Flutter？"><a href="#什么是Flutter？" class="headerlink" title="什么是Flutter？"></a>什么是Flutter？</h1><p>Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。它也是构建未来的Google Fuchsia 应用的主要方式。</p><h2 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h2><p>Flutter的主要结构包括：</p><ul><li><p>Flutter engine</p></li><li><p>Flutter framework</p><p>我们看一下这个形象又生动的架构图片：</p></li></ul><p><img src="https://p0.ssl.qhimg.com/t01112f5d526c5a0a0a.png" srcset="/img/loading.gif" alt="Flutter"></p><h5 id="Framework层"><a href="#Framework层" class="headerlink" title="Framework层"></a>Framework层</h5><p>我们来看一下有关部分：<br>        Material   是谷歌UI设计规范、Cupertino 是苹果UI设计规范，我们日常开发经常用这两部分。<br>        Widgets 应用程序用户界面的基本组件，也就是我们开发者在UI开发时着重要处理的部分，官方给到解释是描述Element的配置。<br>        Rendering 抽象布局层，这一层帮助我们完成渲染的初步工作，比如UI元素的位置、大小、绘制等等。<br>        Animation、Painting、Gestures，在代码里面对应的是Dart:UI包，属于底层UI库，主要提供动画、绘制、手势功能。<br>        Foundation    基础工具库</p><p>​        以上就是Framework层，这一层也正是Flutter精髓所在。</p><h5 id="Engine层"><a href="#Engine层" class="headerlink" title="Engine层"></a>Engine层</h5><p>Skia是2D图像渲染引擎、Dart运行时，Text文字处理引擎。</p><p>这个架构图中开发者着重关注Widget开发工作、Material与Cupertino的使用，其他不需要太关心，这些Flutter团队已经帮普通开发者完成了，但是如果稍作了解，对我们对开发还是有很大帮助的。</p><p>接下来我们一起开始源码分析之旅吧^^</p><p><img src="https://p3.ssl.qhimg.com/t01cd78b2cb2616a7d1.png" srcset="/img/loading.gif" alt=""></p><p>这样的页面Flutter Framework是如何处理的？</p><pre><code class="dart">void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget {  // 这个widget是应用程序的根   @override  Widget build(BuildContext context) {    return MaterialApp(      home: MyHomePage(title: &#39;Hello 360&#39;),    );  }}</code></pre><p>我们可以看到在main方法处，调用了runApp方法，这就是Flutter开始加载渲染的入口了。值得我们注意，调用runApp(MyApp())，一般Flutter启动时调用，之后就不再会调用了。这里的MyApp()，就是开发者自定义的rootWidget，即widget的根。也就是这里extends StatelessWidget组件。</p><h2 id="简单的公式描述"><a href="#简单的公式描述" class="headerlink" title="简单的公式描述"></a>简单的公式描述</h2><p>我们知道Flutter的实现有Flutter Framwork 和 Engine两大部分组成，不言而喻，从加载到显示地整个渲染流程极其复杂。从进入runApp方法开始到屏幕上显示出来这个过程，我们可否用一个简单的方程式来简单描述一下呢？</p><p><img src="https://p5.ssl.qhimg.com/t0104ac3c04c244b5fe.png" srcset="/img/loading.gif" alt=""></p><p>1、state就是我们Application内的那些逻辑和内部状态;<br>2、f() 表示用来描述用户界面部分的方法，比如：build方法调用；<br>3、UI 屏幕上显示的布局视图；</p><p>这个方程式很形象生动的描述了这个state变化到UI渲染完成显示的过程。</p><h2 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h2><p>Widget ：小部件，也就是我们开发者在UI开发时着重要处理的部分，官方给到解释是：描述Element的配置信息，属于不可变对象，它的属性是final修饰。</p><h2 id="BuildContext"><a href="#BuildContext" class="headerlink" title="BuildContext"></a>BuildContext</h2><p>用来获取上下文的数据，它实际就是Element，BuildContext是为了开发者不直接操作Element而抽象出来的类，所有Element都继承自BuildContext这个抽象类。</p><h2 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h2><p>表示Widget在树中特定位置的一个实例。因为widgets是不可变的，所以同一个widgets可以同时配置到多个子树。[Element]的配置表示了widget在树中的特定位置。父widget重新构建时会给该位置创建一个新的widget，与给定元素关联的widget就会更改。大多数元素都有一个惟一的子元素，但是有些widget(例如[RenderObjectElement]的子类)可以有多个子元素。</p><h2 id="RenderObject"><a href="#RenderObject" class="headerlink" title="RenderObject"></a>RenderObject</h2><p>表示在渲染树RenderTree上的节点对象。布局绘制工作都跟他有直接关系。</p><h2 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h2><p>Window是Flutter Framework连接宿主操作系统的接口。这里看一下，有关Window的源码</p><pre><code class="dart">class Window {  // 当前设备的DPI  double get devicePixelRatio =&gt; _devicePixelRatio;  // Flutter绘制区域的大小  Size get physicalSize =&gt; _physicalSize;  // 当绘制区域大小改变回调  VoidCallback get onMetricsChanged =&gt; _onMetricsChanged;    // 绘制前回调，一般会受显示器的垂直同步信号VSync驱动，当屏幕刷新时就会被调用  FrameCallback get onBeginFrame =&gt; _onBeginFrame;  // 绘制回调    VoidCallback get onDrawFrame =&gt; _onDrawFrame;  // 调度Frame，该方法执行后，onBeginFrame和onDrawFrame将紧接着会在合适时机被调用，  // 此方法会直接调用Flutter engine的Window_scheduleFrame方法  void scheduleFrame() native &#39;Window_scheduleFrame&#39;;  // 更新应用在GPU上的渲染,此方法会直接调用Flutter engine的Window_render方法  void render(Scene scene) native &#39;Window_render&#39;;  // 发送平台消息  void sendPlatformMessage(String name,ByteData data,  PlatformMessageResponseCallback callback);}</code></pre><h1 id="入口执行3步走"><a href="#入口执行3步走" class="headerlink" title="入口执行3步走"></a>入口执行3步走</h1><pre><code class="dart">void runApp(Widget app) {  WidgetsFlutterBinding.ensureInitialized()    ..attachRootWidget(app)    ..scheduleWarmUpFrame();}</code></pre><p>渲染widget并上载到屏幕上，框架给了我们这三步骤。</p><h5 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h5><p><code>WidgetsFlutterBinding.ensureInitialized()</code></p><p>WidgetsFlutterBinding初始化操作：这是一个单例模式，负责创建WidgetsFlutterBinding对象，这个对象继承抽象类BindingBase，并且附带7个mixin Binding，初始化渲染、语义化、绘制、平台消息以及手势等一系列操作；我理解这里就是做了全局调用的准备性工作，此时在还不会被触发。我们先看一下这个时序图，先有个整体概念。</p><p><img src="https://p5.ssl.qhimg.com/t01402aacf4a9c0b11a.png" srcset="/img/loading.gif" alt=""></p><p>1、把给定的widget渲染并贴到屏幕上去。<br>2、Widgets框架与应用程序绑定到一起的具体实现，就像胶水一样将framework与Flutter引擎关联在一起。<br>3、作为一个单例实现，也就是系统中只有这么一份。</p><p>我们一起看看Framework代码是如何处理的：</p><pre><code class="dart">class WidgetsFlutterBinding extends BindingBase                             with                                  GestureBinding,                                  ServicesBinding,                                  SchedulerBinding,                                  PaintingBinding,                                  SemanticsBinding,                                  RendererBinding,                                  WidgetsBinding {  static WidgetsBinding ensureInitialized() {    if (WidgetsBinding.instance == null)      WidgetsFlutterBinding();    return WidgetsBinding.instance;  }}</code></pre><p>此binding绑定到window上，代码内拿到的ui.window实例。</p><p>实例代码：<code>ui.Window get window =&gt; ui.window;</code></p><p>另外，我们继续跟进代码的过程中，发现在BindingBase有初始化，并且添加持久帧的回调PersistentFrameCallback，在应用程序的生命周期内，每一帧渲染都会调用它们。</p><h6 id="RenderBinding"><a href="#RenderBinding" class="headerlink" title="RenderBinding"></a>RenderBinding</h6><pre><code class="dart">@protected  void drawFrame() {    pipelineOwner.flushLayout();    pipelineOwner.flushCompositingBits();    pipelineOwner.flushPaint();    // 把bits发送到GPU    renderView.compositeFrame();     // 同时把语义发送给操作系统    pipelineOwner.flushSemantics();   }</code></pre><h6 id="WidgetBinding"><a href="#WidgetBinding" class="headerlink" title="WidgetBinding"></a>WidgetBinding</h6><pre><code class="dart">@override  void drawFrame() {    try {      if (renderViewElement != null)        buildOwner        .buildScope(renderViewElement);      super.drawFrame();      buildOwner.finalizeTree();    } finally {    }  }</code></pre><p>最后代码跟踪到这个地方，我们看一下这段代码，所有压入render渲染管道的数据，都是经过这个方法生成每一帧的，在布局和画帧时会由Flutter引擎先调用handleDrawFrame，再调用这个方法。</p><h6 id="每一帧合成经历过什么？"><a href="#每一帧合成经历过什么？" class="headerlink" title="每一帧合成经历过什么？"></a>每一帧合成经历过什么？</h6><h6 id="合成需要8个阶段："><a href="#合成需要8个阶段：" class="headerlink" title="合成需要8个阶段："></a>合成需要8个阶段：</h6><h6 id="1、动画阶段："><a href="#1、动画阶段：" class="headerlink" title="1、动画阶段："></a>1、动画阶段：</h6><p>在[Window.onBeginFrame]注册的[handleBeginFrame]方法，按顺序执行所有的临时帧回调[scheduleFrameCallback]。每一个动画都是由[Ticker]实例来驱动[AnimationController]执行。</p><h6 id="2、微任务："><a href="#2、微任务：" class="headerlink" title="2、微任务："></a>2、微任务：</h6><p>由临时帧回调调度的微任务，在方法[handleBeginFrame]执行返回后开始执行。 通常包括完成此帧的[Ticker]s和[AnimationController]s的回调。 注册到[Window.onDrawFrame]的方法，在[handleBeginFrame], [handleDrawFrame]之后会调用持久性帧的回调方法。</p><h6 id="3、布局阶段："><a href="#3、布局阶段：" class="headerlink" title="3、布局阶段："></a>3、布局阶段：</h6><p>系统中所有的标记为dirty的[RenderObject]s，此时会安排妥当。</p><h6 id="4、合成bits阶段-："><a href="#4、合成bits阶段-：" class="headerlink" title="4、合成bits阶段 ："></a>4、合成bits阶段 ：</h6><p>这个阶段会在dirty [RenderObject]更新时进行。</p><p>5、绘制阶段 ：</p><p>系统中所有被标记为dirty 的[RenderObject]s都会被重新绘制。 标记方法调用[RenderObject.markNeedsPaint]。</p><h6 id="6、合成图层阶段："><a href="#6、合成图层阶段：" class="headerlink" title="6、合成图层阶段："></a>6、合成图层阶段：</h6><p>图层树被转换成[Scene]并发送给GPU。Scene对象是一个数据结构，保存最终渲染后的像素信息。</p><h6 id="7、语义阶段："><a href="#7、语义阶段：" class="headerlink" title="7、语义阶段："></a>7、语义阶段：</h6><p>在系统内所有被标记为脏的[RenderObject]s都更新了他们的语义。此时会生成语义节点树。可以参考[RenderObject.markNeedsSemanticsUpdate]详细标明一个语义的dirty对象</p><h6 id="8、最终阶段："><a href="#8、最终阶段：" class="headerlink" title="8、最终阶段："></a>8、最终阶段：</h6><p>在[drawFrame]方法返回以后[handleDrawFrame]会调用到前面初始化的时候通过[addPostFrameCallback]方法注册进来的post-frame回调。</p><h6 id="drawFrame方法中调用到的方法释义："><a href="#drawFrame方法中调用到的方法释义：" class="headerlink" title="drawFrame方法中调用到的方法释义："></a>drawFrame方法中调用到的方法释义：</h6><h6 id="1、flushLayout："><a href="#1、flushLayout：" class="headerlink" title="1、flushLayout："></a>1、flushLayout：</h6><p>这是更新所有被标记为dirty的RenderObject对象的布局信息。 为了将对象呈现在屏幕新的位置上，此时布局信息绘制被清除掉。</p><p>2、flushComposittingBits：</p><p>这个方法在[flushLayout]之后与[flushPaint]之前调用，也就是渲染的第二关键步骤。它用来访问所有的子节点，判断是否需要组合，用[markNeedsPaint]方法来做标记哪些渲染对象发生了变化，最后完成所有需要组合的bits更新操作。 </p><h6 id="3、flushPaint："><a href="#3、flushPaint：" class="headerlink" title="3、flushPaint："></a>3、flushPaint：</h6><p>它是用来更新显示列表的所有渲染对象。绘制阶段发生在Layout之后和Scene被重新组合之前，Scene是由每个渲染对象的最新显示列表组成。 使用深度优先策略，按相反的顺序对脏节点排序。</p><h6 id="4、compositeFrame："><a href="#4、compositeFrame：" class="headerlink" title="4、compositeFrame："></a>4、compositeFrame：</h6><p>首先它是renderView的方法<br>将所有组合好的布局树上载到引擎。也就是发送bits 到 GPU。<br>最后把呈现管道的输出出现在屏幕上。 这里调用了 window类的方法，<code>_window.render(scene);</code></p><h6 id="5、flushSemantics："><a href="#5、flushSemantics：" class="headerlink" title="5、flushSemantics："></a>5、flushSemantics：</h6><p>把语义的变化发送到操作系统。</p><p>到此，第一步告一段落，用一副比较形象的图来表示Flutter布局渲染的整体流程：</p><p><img src="https://p3.ssl.qhimg.com/t01895e71701aa19a51.png" srcset="/img/loading.gif" alt=""></p><p>1、用户操作后触发更新运行动画，导致Widget State 的改变；<br>2、Widget State改变触发 Flutter framework 构建新的Widget树；<br>3、Framework根据新与旧 Widget树的差异更新Render树，从新排版界面布局；<br>4、新的Render树合成输出新的图层树，最后发送给到GPU显示到屏幕上；</p><h5 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h5><p><code>..attachRootWidget(app)</code></p><p>进行级联调用attachRootWidget，遍历挂载整个视图树，并建立Widget、Element、RenderObject之间的连接与关系，此处Element的具体类型为RenderObjectToWidgetElement；我们先看一下这个时序图，先有个整体概念。<img src="https://p5.ssl.qhimg.com/t017d3101d2aa744ef5.png" srcset="/img/loading.gif" alt=""></p><p>首先我们来看一下下面的这些方法：<br>1、attachRootWidget(app)，将获取到的widget 附加到 [renderViewElement]上，必要的时候才会去创建它。这个方法只有在[runApp]方法配置widget树时调用它。<br>2、RenderObjectToWidgetAdapter就是一个桥接，Widget与RenderObject之间的一个桥接类。<br>3、RenderObjectToWidgetAdatper这个桥接类与RenderObjectToWidgetElement涉及到几个方法分别是：attachToRenderTree、</p><p>createElement、</p><p>mount、</p><p>rebuild、</p><p>updateChild，</p><p>inflateWidget，</p><p>就是将创建出来的元素element关联到render树上，将widget、element、RenderObject建立关系。当然这里面涉及到一些构建更新渲染到策略，后面由涉及到。</p><h6 id="attachToRenderTree"><a href="#attachToRenderTree" class="headerlink" title="attachToRenderTree"></a>attachToRenderTree</h6><pre><code>void attachRootWidget(Widget rootWidget) {    _renderViewElement = RenderObjectToWidgetAdapter&lt;RenderBox&gt;(      container: renderView,      debugShortDescription: &#39;[root]&#39;,      child: rootWidget    ).attachToRenderTree(buildOwner, renderViewElement);  }</code></pre><p>这是attachRootWidget方法，也就是上图到第一步。 由[runApp]调用将配置好的widget树关联到[renderViewElement]上。</p><h6 id="attachToRenderTree-1"><a href="#attachToRenderTree-1" class="headerlink" title="attachToRenderTree"></a>attachToRenderTree</h6><pre><code class="dart">RenderObjectToWidgetElement&lt;T&gt; attachToRenderTree(BuildOwner owner,   [RenderObjectToWidgetElement&lt;T&gt; element]) {    if (element == null) {      owner.lockState(() {        element = createElement();        assert(element != null);        element.assignOwner(owner);      });      owner.buildScope(element, () {        element.mount(null, null);      });    } else {      element._newWidget = this;      element.markNeedsBuild();    }    return element;  }</code></pre><p>这里attachToRenderTree方法，主要是用于[runApp]加载应用程序，根据不同策略创建更新构建Widget、Element、RenderObject的对应关系。如果“element”为空，这个函数将创建一个新元素。否则，给定的元素Element更新对应关系到这个Widget。</p><p>下面我们一起看看每个方法的简单逻辑</p><h6 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h6><pre><code class="dart">@overrideRenderObjectToWidgetElement&lt;T&gt; createElement() =&gt; RenderObjectToWidgetElement&lt;T&gt;(this);class RenderObjectToWidgetElement&lt;T extends RenderObject&gt; extends RootRenderObjectElement {  ///创建基于[RenderObject]托管的Element  RenderObjectToWidgetElement(RenderObjectToWidgetAdapter&lt;T&gt; widget)   : super(widget);</code></pre><p>创建基于[RenderObject]托管的Element</p><h6 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h6><pre><code class="dart">@override  void mount(Element parent, dynamic newSlot) {    assert(parent == null);    super.mount(parent, newSlot);    _rebuild();  }</code></pre><p>mount过程就是将element挂载到父类到槽上去。</p><h6 id="rebuild"><a href="#rebuild" class="headerlink" title="_rebuild"></a>_rebuild</h6><pre><code> void _rebuild() {    try {      _child = updateChild(_child, widget.child, _rootChildSlot);    } catch (exception, stack) {      final Widget error = ErrorWidget.builder(details);      _child = updateChild(null, error, _rootChildSlot);    }  }</code></pre><p>_rebuild的过程，调用update进行了child节点的更新操作。</p><h6 id="updateChild"><a href="#updateChild" class="headerlink" title="updateChild"></a>updateChild</h6><p>这个方法就不贴代码了，对child节点进行更新的策略如下图：</p><p><img src="https://p0.ssl.qhimg.com/t0123993c0bd88b7dcb.png" srcset="/img/loading.gif" alt=""></p><p>判断是否更新child在代码里面，就是查看当前child是否相符，也就是键值Key与运行时runtimeType是否完全一样，是的话就认为是一个类型型号的child节点。稍后会说到这一块的更新策略在Framework中怎么落地的。</p><h6 id="inflateWidget"><a href="#inflateWidget" class="headerlink" title="inflateWidget"></a>inflateWidget</h6><pre><code class="dart">  @protected  Element inflateWidget(Widget newWidget, dynamic newSlot) {    final Key key = newWidget.key;    if (key is GlobalKey) {      final Element newChild = _retakeInactiveElement(key, newWidget);      if (newChild != null) {        newChild._activateWithParent(this, newSlot);        final Element updatedChild = updateChild(newChild, newWidget, newSlot);        return updatedChild;      }    }    final Element newChild = newWidget.createElement();    newChild.mount(this, newSlot);    return newChild;  }</code></pre><p>看到inflateWidget方法，在GlobalKey中查找newWidget的Key，查看是否有可以复用到Element，然后就可以更新可复用的Element。当然如果有没有找到的话，就需要创建新的Element啦。</p><p>经过上面流程的分析用下图总结流程流转过程：</p><p><img src="https://p4.ssl.qhimg.com/t013a3d006ac22b3240.png" srcset="/img/loading.gif" alt=""></p><p>Widget部分：存放渲染内容、视图布局信息。<br>Element部分：存放上下文，通过Element遍历视图树，Element同时持有Widget和RenderObject。<br>RenderObject部分：根据Widget的布局属性进行Layout，Paint， Widget传入的内容构建Layer树。</p><h5 id="第三步："><a href="#第三步：" class="headerlink" title="第三步："></a>第三步：</h5><p><code>..scheduleWarmUpFrame();</code></p><p>再次进行级联调用scheduleWarmUpFrame，这里用来调度预热帧，执行帧绘制方法handleBeginFrame和handleDrawFrame。此时会触发布局渲染工作。</p><p>这里面有一个有意思的点就是当再次调用[runApp]这个方法，会用新的widget替换屏幕上之前的旧的widget。工作机理是新旧widget树比对，将差异点应用于底层呈现树。举个直接的例子，就类似于我们写的计数器的demo，[StatefulWidget]在调用[State.setState]后重新构建[State.setState]时所发生的变化。</p><p><img src="https://p0.ssl.qhimg.com/t013a7edb98c69f18f1.png" srcset="/img/loading.gif" alt=""></p><p>这里方法调用就比较简单了，涉及到的方法少，但是做的事情非常重要。我们先简单看一下几个方法：<br>1、scheduleWarmUpFrame，执行热身帧，在SchedulerBinding内执行的方法<br>2、handleBeginFrame准备执行帧绘制<br>3、handleDrawFrame引擎调用准备出来一个新的帧<br>4、scheduleFrame在适当的时机，请求调用window类的[onBeginFrame]和[onDrawFrame]回调。</p><p>我们一起看一下这里的代码</p><h6 id="scheduleWarmUpFrame"><a href="#scheduleWarmUpFrame" class="headerlink" title="scheduleWarmUpFrame"></a>scheduleWarmUpFrame</h6><pre><code class="dart">void scheduleWarmUpFrame() {    ///使用定时器确认微任务执行刷新    Timer.run(() {      // 使用定时器准备执行帧绘制      handleBeginFrame(null);    });    Timer.run(() {      handleDrawFrame();      //重置时间戳，避免帧跳跃      resetEpoch();      _warmUpFrame = false;      if (hadScheduledFrame)        scheduleFrame();    });    // 事件锁定，    // 保证在执行期间不会有其他任务穿插入进来    lockEvents(() async {      await endOfFrame;      Timeline.finishSync();    });  }</code></pre><p>这个方法在响应到系统Vsync信号前，尽可能快的去执行一帧绘制。<br>先简单看一下第一个方法内代码执行的具体方法，这里有注释，可以简单看一下。</p><h6 id="scheduleFrame"><a href="#scheduleFrame" class="headerlink" title="scheduleFrame"></a>scheduleFrame</h6><pre><code class="dart">void scheduleFrame() {    if (_hasScheduledFrame          || !_framesEnabled)      return;    ..........    window.scheduleFrame();    _hasScheduledFrame = true;  }在适当的时机，请求[onBeginFrame]和[onDrawFrame]回调。void scheduleFrame() native &#39;Window_scheduleFrame&#39;;</code></pre><p>方法[scheduleFrame]，需要注意的是：</p><p>1、在设备屏幕关闭时，调用可能会延迟；</p><p>2、当屏幕再次打开并且应用程序可见时，才会被调用。</p><p>还有特别有意思的是，在当前帧未完成情况下，如果我们调用此函数，就会强制调度到另一个帧。在通常情况下，调度帧是由操作系统发出的“Vsync”信号来触发。</p><p>在看代码的时候，还有看到过另外相关一个方法，在这里做个对比：</p><p>1、[scheduleForcedFrame], 忽略[lifecycleState]强制执行一帧；<br>2、[scheduleWarmUpFrame]，忽略”Vsync”信号立即尽可能早的执行一帧；</p><h1 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h1><h3 id="1、Widget-变化对布局的影响"><a href="#1、Widget-变化对布局的影响" class="headerlink" title="1、Widget 变化对布局的影响"></a>1、Widget 变化对布局的影响</h3><h5 id="Widget-变化对布局的影响（情形一）"><a href="#Widget-变化对布局的影响（情形一）" class="headerlink" title="Widget 变化对布局的影响（情形一）"></a>Widget 变化对布局的影响（情形一）</h5><p><img src="https://p5.ssl.qhimg.com/t017ed2d9a9788d65d0.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://p1.ssl.qhimg.com/t01b00cbb8751ccdb50.png" srcset="/img/loading.gif" alt=""></p><p>第一次完成布局后，看到是对应关系如上虚线部分。当黄色矩形发生颜色变化时，它并没有新建 Element，而是复用了之前矩形 的 Element，由于矩形并没有改变 Widget 类型，所以 Element 只需要根据新的 Widget 修改自身的颜色配置参数作为新的 Widget 距可以了。正是通过这种可变与不可变对象的组合，使得Flutter布局模式灵活而又高效。</p><h5 id="Widget-变化对布局的影响（情形二）"><a href="#Widget-变化对布局的影响（情形二）" class="headerlink" title="Widget 变化对布局的影响（情形二）"></a>Widget 变化对布局的影响（情形二）</h5><p><img src="https://p4.ssl.qhimg.com/t015d717353e1ba68cd.png" srcset="/img/loading.gif" alt=""></p><p>情形二中，子圆形蓝色 Widget变为了 三角形红色，此时 Flutter 的布局重建会有怎样的变化呢？</p><p><img src="https://p2.ssl.qhimg.com/t01fe0248d31133704a.png" srcset="/img/loading.gif" alt=""></p><p>因为矩形 Widget 类型没变化，所以并没有引起 Element 与 Render Object 的实际变化。Element 照常持有了新矩形绿色 Widget 与 矩形RenderObject的引用。</p><p><img src="https://p3.ssl.qhimg.com/t01a21c20bf45202528.png" srcset="/img/loading.gif" alt=""></p><p>三角形红色Widget类型发生了变化，就不可以复用 由 矩形绿色 类型创建的 Element 与 RenderObject，那怎么办呢？</p><p><img src="https://p3.ssl.qhimg.com/t01e9bd142b42b341e5.png" srcset="/img/loading.gif" alt=""><br>此时，Framework 就会更新Widget、Element 与 RenderObject到关系，暂时分离相互之间的关系。我们在前面分析代码时候，看到他们在创建之前是在缓存里面查一下看有没有存在，所以这缓存策略也是优化性能的策略之一。</p><p><img src="https://p0.ssl.qhimg.com/t01e1316ae4d0e8294f.png" srcset="/img/loading.gif" alt=""></p><p>最后，三角形红色Widget 重新调用 createElement() 与 createRenderObject()方法进行构建，再次mount挂载到父节点的 slot 槽上。新的 Element 就与三角形 Widget 和三角形 RenderObject建立了关系。</p><p>通过上面到两个情形，我们发现了布局变化在framework层处理逻辑是不一样的。感兴趣的同学可以再看看源代码。</p><h3 id="2、重布局导致性能影响"><a href="#2、重布局导致性能影响" class="headerlink" title="2、重布局导致性能影响"></a>2、重布局导致性能影响</h3><p>为避免某一渲染对象重布局时触发父级对象的重布局，减少不必要的性能开销，Flutter 框架给出了布局边界控制机制。即通过在某一渲染对象上设置重布局边界，避免重布局的影响范围扩散出去，那满足哪些条件，会自动设置重布局边界呢？</p><p>我们一起看看下面的代码</p><pre><code class="dart">void layout(Constraints constraints,            { bool parentUsesSize = false }) {    RenderObject relayoutBoundary;    if (!parentUsesSize || sizedByParent        || constraints.isTight        || parent is! RenderObject)     {      relayoutBoundary = this;    } else {      final RenderObject parent = this.parent;      relayoutBoundary = parent._relayoutBoundary;    }    if (!_needsLayout     &amp;&amp; constraints == _constraints     &amp;&amp; relayoutBoundary==_relayoutBoundary)     {      return;    }    _constraints = constraints;    _relayoutBoundary = relayoutBoundary;    if (sizedByParent) {      try {        performResize();      } catch (e, stack) {      }    }    。。。。。。。。。。 }</code></pre><p>看到满足边界判断的地方，就直接返回不再去调用执行。总结如下：<br>1、parentUsesSize 为false， 父对象大小与子对象大小无任何依赖的情况。<br>2、sizedByParent 为 true，子对象大小受父对象约束。<br>3、constraints.isTight 父对象对子对象的大小有严格限定。</p><p>下面我们看一下比较形象标识其中一个条件的图：</p><p><img src="https://p3.ssl.qhimg.com/t018365849f5ed381b1.png" srcset="/img/loading.gif" alt=""></p><p>如图满足constraints.isTight 父对象对子孩子的大小有严格限定，红色的弧线部分，此时子对象自动被设置隔离带布局边界，子树的重布局不会扩散到父级。可以说这也是提高性能的好办法。</p><h1 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h1><p>在总结的过程中，朋友们也提出了比较好的问题，这里列举一下：</p><h5 id="1、第三步scheduleWarmUpFrame-可以不调用吗？"><a href="#1、第三步scheduleWarmUpFrame-可以不调用吗？" class="headerlink" title="1、第三步scheduleWarmUpFrame()可以不调用吗？"></a>1、第三步scheduleWarmUpFrame()可以不调用吗？</h5><p>这个方法的作用是，在系统Vsync信号到来之前尽可能快的执行。这个方法最好是在应用程序启动的时候调用的，目的是让第一帧尽可能多的运行几毫秒。如果不调用这个方法，App倒是也可以启动运行，只是界面布局之初可能有那么几毫秒不会进行布局渲染工作，直到系统Vsync信号到来。</p><h6 id="2、Widget、Element、RenderObject-三者对应树关系，为什么有中间这一层Element，而不是widget直接对应RenderObject呢？"><a href="#2、Widget、Element、RenderObject-三者对应树关系，为什么有中间这一层Element，而不是widget直接对应RenderObject呢？" class="headerlink" title="2、Widget、Element、RenderObject 三者对应树关系，为什么有中间这一层Element，而不是widget直接对应RenderObject呢？"></a>2、Widget、Element、RenderObject 三者对应树关系，为什么有中间这一层Element，而不是widget直接对应RenderObject呢？</h6><p>开始看这部分的时候，其实我觉得好奇怪，怎么中间还多了一层Element，这是什么操作呀，在了解到框架设计者的思想后，明白了些许原因。查了一些资料了解到浏览器方面的的技术“虚拟DOM”。它是为解决渲染性能问题而生的，在DOM操作时性能损耗与局部DOM操作更新有一定麻烦，假如对网页上个别标签进行更新，如果此时直接操作整个DOM，那开销是很大的。这个时候就需要有个优化的办法，汇总各个元素的更新情况，通过“diff算法”计算出与原来 DOM 树的差异，最后通过一次 DOM 更新解决，这样的设计使得性能大大提高。在Flutter Framework层对当前需要rebuild的Element都会进行标记为dirty状态，即[markNeedsBuild]方法，这时候可以这么理解 Element 树就是用来发挥“虚拟DOM”的作用，使得视图更高效地完成构建。Element由 Widget 的“配置描述信息”构建出来的结构化组件，里面包含了各种部件的上下文信息。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>360技术训练营实记</title>
    <link href="/2019/07/29/360%E6%8A%80%E6%9C%AF%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AE%9E%E8%AE%B0/"/>
    <url>/2019/07/29/360%E6%8A%80%E6%9C%AF%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AE%9E%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="360技术训练营"><a href="#360技术训练营" class="headerlink" title="360技术训练营"></a>360技术训练营</h2><p>技术训练营是360大学组织的技术分享平台，主要面向360内外的技术小伙伴。很荣幸的在2019年07月27日，作为<strong>讲师</strong>参加了，360互联网技术训练营第17期——Flutter 开发者沙龙。</p><p>本次技术分享活动，主办方包括：360前端TC、360大学、360WEB平台、360导航。</p><h2 id="宣传海报"><a href="#宣传海报" class="headerlink" title="宣传海报"></a>宣传海报</h2><p><img src="http://cdn.huodongxing.com/file/20150608/113C09DD405B15DFAE8510F66ECC9DADBD/30263476749521996.jpeg" srcset="/img/loading.gif" alt=""></p><h2 id="现场情况"><a href="#现场情况" class="headerlink" title="现场情况"></a>现场情况</h2><p>在活动行后台，看到当时报名的人数有600人以上，实际到场的人数有300人以上，到场小伙伴们冒着酷暑，热情一度高涨，场面差点没有压住。上几张图片：</p><p><img src="https://p4.ssl.qhimg.com/t0121ba8af51f7521de.jpg" srcset="/img/loading.gif" alt=""></p><p><img src="https://p.ssl.qhimg.com/t011ad43369077e8e8e.webp" srcset="/img/loading.gif" alt=""></p><p><img src="https://p.ssl.qhimg.com/t01dd2896237e94f283.webp" srcset="/img/loading.gif" alt=""></p><p><img src="https://p.ssl.qhimg.com/t01674b572f4dd0cbde.webp" srcset="/img/loading.gif" alt=""></p><p><img src="https://p.ssl.qhimg.com/t0159882c2557381a06.webp" srcset="/img/loading.gif" alt=""></p><p><img src="https://p3.ssl.qhimg.com/t014032ff429b742dcd.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="特约嘉宾"><a href="#特约嘉宾" class="headerlink" title="特约嘉宾"></a>特约嘉宾</h2><h4 id="Google-中国技术推广大使-程路-（图左第二位）"><a href="#Google-中国技术推广大使-程路-（图左第二位）" class="headerlink" title="Google 中国技术推广大使-程路  （图左第二位）"></a>Google 中国技术推广大使-程路  <em>（图左第二位）</em></h4><h2 id="演讲嘉宾"><a href="#演讲嘉宾" class="headerlink" title="演讲嘉宾"></a>演讲嘉宾</h2><h4 id="1、快手应用研发部平台组iOS工程师-孙恺"><a href="#1、快手应用研发部平台组iOS工程师-孙恺" class="headerlink" title="1、快手应用研发部平台组iOS工程师-孙恺"></a>1、快手应用研发部平台组iOS工程师-孙恺</h4><h4 id="2、Flutter完全手册作者-小德"><a href="#2、Flutter完全手册作者-小德" class="headerlink" title="2、Flutter完全手册作者-小德"></a>2、Flutter完全手册作者-小德</h4><h4 id="3、360导航前端开发专家-赵岩"><a href="#3、360导航前端开发专家-赵岩" class="headerlink" title="3、360导航前端开发专家-赵岩"></a>3、360导航前端开发专家-赵岩</h4><h4 id="4、我"><a href="#4、我" class="headerlink" title="4、我"></a>4、我</h4><h2 id="演讲的内容"><a href="#演讲的内容" class="headerlink" title="演讲的内容"></a>演讲的内容</h2><p>这主要连接一下分享的内容，<a href="https://donald99.github.io/2019/08/06/Flutter从加载到显示">Flutter从加载到显示</a></p><p>1、Widget、Element、RenderObject基本概念；</p><p>2、在Flutter Framework层从创建到渲染的流程；</p><p>3、Flutter在构建布局方面是如何提高效率的；</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这样的分享会议以及业界技术大会，积极参与，认识更多优秀的小伙伴，共舞。</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Google I/O 2019 参会经历</title>
    <link href="/2019/05/20/Google%20I:O%202019%20%E5%8F%82%E4%BC%9A%E5%88%86%E4%BA%AB/"/>
    <url>/2019/05/20/Google%20I:O%202019%20%E5%8F%82%E4%BC%9A%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="Google-I-O-2019-参会经历"><a href="#Google-I-O-2019-参会经历" class="headerlink" title="Google I/O 2019 参会经历"></a>Google I/O 2019 参会经历</h2><p><img src="https://p2.ssl.qhimg.com/t01d581fe0ed3842bd8.gif" srcset="/img/loading.gif" alt="Google I/O 2019"></p><p>感谢的话写在前面，感谢领导给的机会可以公费参加技术大会，感谢行程中帮助我的小伙伴，感谢期间认识的好朋友，很开心的说。</p><h2 id="Google-I-O-预订"><a href="#Google-I-O-预订" class="headerlink" title="Google  I/O 预订"></a>Google  I/O 预订</h2><p>在官方网站上，抱着试试的态度参加了预约，幸运的被选中，成了Lucky dog，收到确认邮件，邀请信。</p><p><img src="https://p.ssl.qhimg.com/dr/1278_630_100/t01212ab1a7feea921e.webp" srcset="/img/loading.gif" alt=""></p><p>大会的确认购票有3种：学术交流、合作伙伴、普通人员。当然对应着价格也是不一样的。还有你不知道的第四种，Google 分布在全球GDG的服务人员以及GDE都是免费的身份参加的。争取有一天能凭借自己的技术能力成为GDE，come on！</p><h2 id="护照签证"><a href="#护照签证" class="headerlink" title="护照签证"></a>护照签证</h2><p>第一次办理美国签证，据说会有被拒的可能，心怀忐忑，去大使馆签证面签B1&amp;B2，使用上了蹩脚的口语，最后签证通过。这样的商务签比较好通过，我觉的提供的邀请函帮了很大忙。</p><p><img src="https://p4.ssl.qhimg.com/t019ba0cbd2a89021d7.png" srcset="/img/loading.gif" alt="邀请函"></p><h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><p>1、在美国大使馆网站申报DS-160清单；</p><p>2、面签通过，绿色单子；面签拒签，白色单子；</p><p>4、一定要在 EVUS 登记个人信息，Enrolled状态；</p><p>5、出发前带上护照签证复印件、身份证复印件，带上以备不时之需；</p><p>3、护照EMS邮递护照到家或去中信银行网点自取，费用自理；</p><h2 id="订机票酒店"><a href="#订机票酒店" class="headerlink" title="订机票酒店"></a>订机票酒店</h2><p>1、提供护照号码，往返日期、航班号，感谢公司同事帮忙预定机票；</p><p><img src="https://p.ssl.qhimg.com/dr/582_724_100/t01f6605f48c8b1dbb5.webp" srcset="/img/loading.gif" alt="机票"></p><p>2、Booking 上预定经济酒店 Mountain View Inn，感谢李老师推荐；</p><p><img src="https://p.ssl.qhimg.com/dr/844_574_100/t0170eede82bbe357c2.webp" srcset="/img/loading.gif" alt="Mountain View Inn"></p><h2 id="交通"><a href="#交通" class="headerlink" title="交通"></a>交通</h2><p>1、打车费用公司实报实销，不报销租车费用，会议期间uber 和 lyft 在会场附近免费乘车，但很难打到车</p><p>2、公共交通不发达，前5天蹭朋友的车，最后一天自己租车，开车去了一趟旧金山金门大桥，风景确实不错</p><p>3、租租车APP（zuzuche.com），预约后，去Budget车行取车</p><p><img src="https://p.ssl.qhimg.com/dr/494_492_100/t01e6edb4dc14cd2a20.webp" srcset="/img/loading.gif" alt=""></p><p>在自驾开车过程，发现汽车礼让行人这一块做的非常好，行人不过斑马线，车子就一直停着不动。</p><p><img src="https://p.ssl.qhimg.com/dr/432_476_100/t01bbff5b1963398245.webp" srcset="/img/loading.gif" alt=""></p><h2 id="饮食"><a href="#饮食" class="headerlink" title="饮食"></a>饮食</h2><p>第一顿饭吃的KFC，难吃啊，不喜欢太油的</p><p><img src="https://p.ssl.qhimg.com/dr/478_728_100/t0148b3d0c7f1f388ee.webp" srcset="/img/loading.gif" alt=""></p><p>在Inn的早餐</p><p><img src="https://p.ssl.qhimg.com/dr/926_600_100/t01bb0798d76684c138.webp" srcset="/img/loading.gif" alt=""></p><p>会场提供的餐食</p><p><img src="https://p.ssl.qhimg.com/dr/694_684_100/t01686e1ed10c2f9fc0.webp" srcset="/img/loading.gif" alt=""></p><p><img src="https://p.ssl.qhimg.com/dr/716_636_100/t0179cf401f3988ea26.webp" srcset="/img/loading.gif" alt=""></p><p><img src="https://p.ssl.qhimg.com/dr/812_690_100/t01c267b96f7984ce3d.webp" srcset="/img/loading.gif" alt=""></p><p>参观Facebook时吃的午餐，总之各种酱，各种风味，还有些不太习惯</p><p><img src="https://p.ssl.qhimg.com/dr/926_600_100/t0179fa32b7d74fbc1b.webp" srcset="/img/loading.gif" alt=""></p><p>Facebook 前台</p><p><img src="https://p.ssl.qhimg.com/dr/694_456_100/t0169338e252d29435d.webp" srcset="/img/loading.gif" alt=""></p><h2 id="出发前准备的资料"><a href="#出发前准备的资料" class="headerlink" title="出发前准备的资料"></a>出发前准备的资料</h2><p>1、日程安排，Google IO APP 和 网站里面，可以查看每天的Sessions、Events、App review、Garage、Workshop、Demo体验馆，CodeLab</p><p>2、打印旅行机票信息，保险单</p><p>3、通讯工具，购买适合自己手机支持的SIM卡，T-Mobile、AT&amp;T（信号好）、或租赁移动Wi-Fi</p><p>准备什么？</p><p>4、预约银行兑换美元现金，基本用不上</p><p>5、Visa信用卡、Master信用卡、个别地方也可以用银联卡</p><p>6、个人名片，发给有缘人</p><h2 id="Google-I-O-Mixer"><a href="#Google-I-O-Mixer" class="headerlink" title="Google  I/O Mixer"></a>Google  I/O Mixer</h2><p><img src="https://p.ssl.qhimg.com/dr/1920_418_100/t010c565d3c52c23aa0.webp" srcset="/img/loading.gif" alt="Google I/O Mixer"></p><p>在通行小伙伴的推荐下，报名参加了这次的颁奖典礼，主要是颁给那些优秀的APP设计开发人员，此处是羡慕的眼神。</p><p>以下是上榜的名单：</p><p><img src="https://p.ssl.qhimg.com/t018d178a44c554c27a.webp" srcset="/img/loading.gif" alt="光荣榜"></p><p>大家露天地里，喝着啤酒吃烧烤，聊着天。虽然聊的更多是工作相关的，但很尽兴，比如你APP有多少用户量，打算投放多少广告费，今年要挣多少钱等等。现场情况：</p><p><img src="https://p.ssl.qhimg.com/dr/1078_704_100/t017e69682bcd01b26f.webp" srcset="/img/loading.gif" alt=""></p><p><img src="https://p.ssl.qhimg.com/dr/534_702_100/t01c88d6d3272d4726f.webp" srcset="/img/loading.gif" alt=""></p><p><img src="https://p.ssl.qhimg.com/dr/600_738_100/t015384fd59d524ecb0.webp" srcset="/img/loading.gif" alt=""></p><p><img src="https://p.ssl.qhimg.com/dr/1060_720_100/t0107259959acb0e0fe.webp" srcset="/img/loading.gif" alt=""></p><p><img src="https://p.ssl.qhimg.com/dr/894_706_100/t01fac27c24995ccb29.webp" srcset="/img/loading.gif" alt=""></p><h2 id="Google-I-O-2019-100件事情"><a href="#Google-I-O-2019-100件事情" class="headerlink" title="Google I/O 2019 100件事情"></a>Google I/O 2019 100件事情</h2><p>此行的主要就是要能够第一时间了解最前沿的技术动向，今年一共有100件事情，如下表格：</p><table><thead><tr><th>Hardware</th><th>Assistant</th><th>AI and ML</th></tr></thead><tbody><tr><td>Google News and Search</td><td>Augmented Reality and Google Lens</td><td>Privacy</td></tr><tr><td>Android</td><td>Chrome</td><td>Ads</td></tr><tr><td>Accessibility</td><td>More developer announcements</td><td>……</td></tr></tbody></table><p>这里有视频的<a href="https://blog.google/technology/developers/100-things-we-announced-io-19/">历史回放</a></p><p>现场的技术氛围非常浓厚，每个人都是竖起耳朵来听的，哈哈。这个人认识吗？</p><p><img src="https://p.ssl.qhimg.com/dr/1598_1150_100/t01221b57965774b7f4.webp" srcset="/img/loading.gif" alt="皮柴"> </p><h2 id="比较深刻印象的点"><a href="#比较深刻印象的点" class="headerlink" title="比较深刻印象的点"></a>比较深刻印象的点</h2><ul><li>Tensorflow AI ，癌症预测筛查，印度发洪水，重磅：AI训练库由 100G 压缩到 0.5G ，移植到移动设备成为可能</li><li>AR 人与增强现实，动物产生交互反应</li><li><img src="https://p.ssl.qhimg.com/dr/538_952_100/t018d6edf05811a0347.webp" srcset="/img/loading.gif" alt="img"></li><li>Firebase 实时数据库，防火墙挡住中国开发者视线，Google Cloud + Firebase体验非常棒，只有科学上网</li><li>25亿台Android系统活跃设备</li><li>Home Hub 人机交互，只需要示意一下</li></ul><video id="video" controls="" preload="none" width="700" height="400" > <source id="mp4" src="https://s1.ssl.qhres.com/static/3f611afac8833693.mp4" type="video/mp4">  </video><h4 id="入手了Google-Pixel-3A-手机"><a href="#入手了Google-Pixel-3A-手机" class="headerlink" title="入手了Google Pixel 3A 手机"></a>入手了Google Pixel 3A 手机</h4><p>Google Pixel 3a &amp; xl 手机发布</p><p>这个手机的价格很是亲民，相较之前，价格减半，3a $399，3a XL $479。相机效果也不错，AI 优化图像晚上的效果如图对比，</p><p><img src="https://p.ssl.qhimg.com/t011c0aa5e67dd07067.webp" srcset="/img/loading.gif" alt="img">，可见谷歌还是卖软件服务的公司，如此强大的服务能力。另外因为要降低成本，删减了无线充电模块。手机内存是64G的。还原0.5mm耳机孔。运营商支持Verizon、T-Mobile、Sprint、US.Cellular、Google Fi。</p><h4 id="Google-Fi"><a href="#Google-Fi" class="headerlink" title="Google Fi :"></a>Google Fi :</h4><p>a、不受限制的访问网络；<br>b、可以使用不向中国大陆地区提供的服务；<br>c、信号质量很好，全球漫游，流量费用统一为 $10/GB；</p><p>手机到手前，有个小插曲，手机是不支持中国大陆购买的，因为时间比较赶，等不了收到手机，就在加州 mountain view inn 内访问直接下单了，寄送到 在Facebook工作的 宏昊哥那，拖他帮忙再寄送到国内。奇迹发生了，从加州运送到国内要$100 ，真让人头大。多方周折过去，宏昊哥帮忙找了参加WWDC的【码小奋】同学，帮忙带到了上海，从国内快递到北京，顺丰快递陆运费15元的3000元保价+16元运费，共计31元。满满的都是感谢， $100 降到 ¥31，饱含的不仅是省钱，更多的是相互之间的友情，友情无价。</p><p>拆机图片：</p><p><img src="https://p3.ssl.qhimg.com/t01d8c3327a0df46a6e.jpg" srcset="/img/loading.gif" alt="拆机图片"></p><h1 id="CodeLabs"><a href="#CodeLabs" class="headerlink" title="CodeLabs"></a>CodeLabs</h1><p>在大会现场的 <a href="http://clmirror.storage.googleapis.com/index.html">CodeLabs</a> 有老爷爷维持秩序，这也许就是Google的扫地僧吧，哈哈，狠角色。附上在排队的时候拍照：</p><p><img src="https://p.ssl.qhimg.com/dr/672_898_100/t01dca0380b72e781a9.webp" srcset="/img/loading.gif" alt=""></p><p><img src="https://p.ssl.qhimg.com/dr/1176_898_100/t014bf92206f0a0ec55.webp" srcset="/img/loading.gif" alt=""></p><p>现场很多开发者参加的积极性非常高，官方宣称，学习课程上机操作可以赢来年大会的票。</p><h3 id="GDG"><a href="#GDG" class="headerlink" title="GDG"></a>GDG</h3><p><a href="https://chinagdg.org/">谷歌开发者社区</a></p><p> <img src="https://p.ssl.qhimg.com/dr/1182_300_100/t01f75a6aba7a2bb41b.webp" srcset="/img/loading.gif" alt="img"></p><h2 id="GDE"><a href="#GDE" class="headerlink" title="GDE"></a>GDE</h2><p><a href="https://chinagdg.org/google-developer-experts/">谷歌开发者社区专家</a></p><p><img src="https://p.ssl.qhimg.com/t015ca69c8ce131f95a.webp" srcset="/img/loading.gif" alt="img"></p><h2 id="硅谷参观"><a href="#硅谷参观" class="headerlink" title="硅谷参观"></a>硅谷参观</h2><p><img src="https://p.ssl.qhimg.com/dr/1028_686_100/t01e187443012092125.webp" srcset="/img/loading.gif" alt=""></p><p><img src="https://p.ssl.qhimg.com/dr/1160_796_100/t01dea0bf19b242ff47.webp" srcset="/img/loading.gif" alt=""></p><p><img src="https://p.ssl.qhimg.com/dr/752_564_100/t0149adbeb88ed003d3.webp" srcset="/img/loading.gif" alt=""></p><p>有趣的事情 Facebook 把 SUN 的牌子翻过来直接就用上了，节省成本，保留之前的，寓意也是深刻的，只是翻篇不是替代。SUN早些年被Oracle收购。</p><video id="video" controls="" preload="none" width="700" height="400" > <source id="mp4" src="https://s3.ssl.qhres.com/static/1d133d09a8967eb8.mp4" type="video/mp4">  </video><h2 id="斯坦福大学"><a href="#斯坦福大学" class="headerlink" title="斯坦福大学"></a>斯坦福大学</h2><p>会议结束后，跟几个小伙伴参观了斯坦福大学，可惜的是赶上他们做礼拜，没能进入教室内部，只在校园里面溜达。斯坦福的氛围真的太好，要是有能在此修学的机会，此生无憾。</p><p><img src="https://p.ssl.qhimg.com/dr/756_564_100/t01c72edb9ce53eb500.webp" srcset="/img/loading.gif" alt=""></p><p>我最喜欢的一片草坪，又厚又软，很大同学老师在上面踢足球玩耍，</p><p><img src="https://p.ssl.qhimg.com/dr/1174_782_100/t01178d55f2cdcebeae.webp" srcset="/img/loading.gif" alt=""></p><p>有名的 Hoover 塔，当时没开门，上不去。传奇人物美国第31任总统胡佛。</p><p><img src="https://p.ssl.qhimg.com/dr/924_616_100/t01a4bc568268998a21.webp" srcset="/img/loading.gif" alt=""></p><h2 id="旧金山-金门大桥"><a href="#旧金山-金门大桥" class="headerlink" title="旧金山.金门大桥"></a>旧金山.金门大桥</h2><p><img src="https://p.ssl.qhimg.com/dr/1250_832_100/t01cdc2ed7b8bc33e14.webp" srcset="/img/loading.gif" alt=""></p><p><img src="https://p.ssl.qhimg.com/dr/776_516_100/t01c9116018a064687e.webp" srcset="/img/loading.gif" alt=""></p><p><img src="https://p.ssl.qhimg.com/dr/1220_812_100/t010a3c96a636c78fab.webp" srcset="/img/loading.gif" alt=""></p><h2 id="返程"><a href="#返程" class="headerlink" title="返程"></a>返程</h2><p>遇墨西哥籍老外，Bernardo Gonzalez 是一名医生，到中国做医疗设备的生意。</p><p><img src="https://p.ssl.qhimg.com/dr/946_702_100/t01b85b98cec2c61aa2.webp" srcset="/img/loading.gif" alt=""></p><p>我们逆风12个小时06分钟飞行，长途跋涉才回到北京首都国际机场。</p><p><img src="https://p.ssl.qhimg.com/dr/1068_704_100/t015fe4bdc11f4f6801.webp" srcset="/img/loading.gif" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、刘姥姥进大观园——长了见识；</p><p>2、空气环境好，没有重工业，另外这可能是转嫁给了其他国家；</p><p>3、7200人会场组织井井有条；</p><p>4、来自全世界各个国家的开发者，各种各样；</p><p>5、紧跟Google技术发展之路，未来可期；</p><p>6、谷歌最大的威胁或许正来自它的成功，让谷歌的技术惠及每一个人（Building a more helpful Google for everyone）。</p><p>7、这个时候，媳妇问我，最痛苦的事情是什么？最高兴的事情是什么？我的答案是，倒时差是最痛苦的，其他遇到的就是最好的，都是高兴事。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Google I/O</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
